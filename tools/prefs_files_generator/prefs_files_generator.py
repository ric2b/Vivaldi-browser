#!/usr/bin/env python
# Copyright (c) 2017 Vivaldi Technologies AS. All rights reserved
"""
This script uses the vivaldi section of prefs_definitions.json in order to
generate a list of preference constants for the various preference paths
declared in that file.

It then uses both the vivaldi and chromium sections to build a list of
preferences that the javascript side is allowed to read from the C++ side.

/!\: This script should never generate data that is used in the process of
determining runtime behavior related to prefs. In feneral, changing anything
in the prefs definitions should work without needing to recompile a new binary.
The only allowable exception is that removing a pref that is actively used by
the binary itself.
"""

import argparse
import json
import os
import re

PREFS_GEN_FILE_HEAD_TEMPLATE = """\
// Copyright (c) 2017 Vivaldi Technologies AS. All rights reserved
//
// This file was automatically generated by prefs_files_generator.py from
// %(origin_name)s. Do not edit.

"""

PREFS_NAMES_H_TEMPLATE = """\
%(top_comments)s
#ifndef %(header_guard)s
#define %(header_guard)s

#include <string_view>

namespace vivaldiprefs {

%(pref_names)s

extern const char kPlatformDefaultKeyName[];

}  // namespace vivaldiprefs

#endif  // %(header_guard)s
"""

PREFS_NAMES_CC_TEMPLATE = """\
%(top_comments)s
#include "%(header_name)s"

namespace vivaldiprefs {

%(pref_constants)s

const char kPlatformDefaultKeyName[] = "default_%(target_os)s";

}  // namespace vivaldiprefs
"""

PREFS_ENUMS_H_TEMPLATE = """\
%(top_comments)s
#ifndef %(header_guard)s
#define %(header_guard)s

namespace vivaldiprefs {
%(pref_enums)s
}  // namespace vivaldiprefs

#endif  // %(header_guard)s
"""

ENUM_DEFINITION_TEMPLATE = """\
enum class %(enum_name)s {
%(enum_values)s
};
"""

ENUM_VALUE_TEMPLATE = """\
  k%(name)s = %(value)s,"""

def generate_prefs_list(current_path, prefs_definitions):
    """Parser preference definitions recursively """
    if 'type' not in prefs_definitions:
        prefs = []
        for definition in prefs_definitions:
            prefs.extend(generate_prefs_list(current_path + '.' + definition,
                                             prefs_definitions[definition]))
        return prefs

    pref_name = ''.join([part.capitalize() for part in
                         re.split('[._]+', current_path)[1:]])

    result = {}

    if prefs_definitions['type'] == 'enum':
        result["enum"] = pref_name + 'Values'
        result["enum_values"] = prefs_definitions['enum_values']

    result['name'] = 'k' + pref_name
    result['path'] = current_path
    result['comment'] = prefs_definitions.get('description', None)
    result['type'] = prefs_definitions['type']
    return [result]

def main():
    """Main script code"""
    parser = argparse.ArgumentParser(
        description='Generates relevant c++ files from vivalid_prefs.json and chrome_prefs.json')

    parser.add_argument('--prefs-definitions', type=argparse.FileType('r'))
    parser.add_argument('--prefs-names-h', type=argparse.FileType('w'))
    parser.add_argument('--prefs-names-cc', type=argparse.FileType('w'))
    parser.add_argument('--prefs-enums-h', type=argparse.FileType('w'))
    parser.add_argument('--root')
    parser.add_argument('--target-os')
    args = parser.parse_args()

    prefs_definitions = json.load(args.prefs_definitions)
    prefs_list = generate_prefs_list('vivaldi', prefs_definitions['vivaldi'])
    prefs_list.sort(key=lambda i: i["name"])
    if not re.match('^(android|linux|mac|win|ios)$', args.target_os):
        raise TypeError('unsupported target-os - ' + args.target_os)

    top_comments  = PREFS_GEN_FILE_HEAD_TEMPLATE % {
        "origin_name": args.prefs_definitions.name
    }

    relative_prefs_names_header = os.path.relpath(os.path.normpath(
        args.prefs_names_h.name), args.root)
    relative_prefs_enums_header = os.path.relpath(os.path.normpath(
        args.prefs_enums_h.name), args.root)

    prefs_names_header_guard = '_'.join(
        [part.upper() for part in re.split('[./\\\\]+', relative_prefs_names_header)]) + '_'

    prefs_enums_header_guard = '_'.join(
        [part.upper() for part in re.split('[./\\\\]+', relative_prefs_enums_header)]) + '_'

    args.prefs_names_h.write(PREFS_NAMES_H_TEMPLATE % {
        "top_comments": top_comments,
        "header_guard": prefs_names_header_guard,
        "pref_names":
            '\n'.join(['%(comment)sextern const char %(name)s[];' % {
                'name': pref['name'],
                'comment':
                    ('// '+ pref['comment'] + '\n') if pref['comment'] else ''
            } for pref in prefs_list]),
    })

    args.prefs_names_cc.write(PREFS_NAMES_CC_TEMPLATE % {
        "top_comments": top_comments,
        "header_name": relative_prefs_names_header,
        "pref_constants":
            '\n'.join(['const char %(name)s[] = "%(path)s";' % {
                'name': pref['name'],
                'path': pref['path']
            } for pref in prefs_list]),
        "target_os": args.target_os,
    })

    args.prefs_enums_h.write(PREFS_ENUMS_H_TEMPLATE % {
        "top_comments": top_comments,
        "header_guard": prefs_enums_header_guard,
        "pref_enums":
            '\n'.join([ENUM_DEFINITION_TEMPLATE % {
                'enum_name': pref['enum'],
                'enum_values': '\n'.join([ENUM_VALUE_TEMPLATE % {
                    'name': ''.join([part.capitalize()
                        for part in name.split("_")]),
                    'value': value
                } for name, value in pref['enum_values'].items()])
            } for pref in prefs_list if 'enum' in pref])
    })

if __name__ == "__main__":
    main()
