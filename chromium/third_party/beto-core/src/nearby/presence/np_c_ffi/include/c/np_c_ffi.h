/*
 Copyright 2023 Google LLC
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

// clang-format off


#pragma once

/* Generated with cbindgen:0.26.0 */

/*
 WARNING: this file is autogenerated by cbindgen. Don't modify this manually.
 Additionally, you should _not_ rely upon the layouts of the generated
 structs and unions if you want your code to be forward-compatible,
 unless a given type explicitly states in its documentation that it has
 a guaranteed forward-compatible layout.
 Instead, you should use _only_ the provided exported function symbols.
*/

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The possible boolean action types which can be present in an Actions data element
 */
enum np_ffi_ActionType {
  NP_FFI_ACTION_TYPE_CROSS_DEV_SDK = 1,
  NP_FFI_ACTION_TYPE_CALL_TRANSFER = 4,
  NP_FFI_ACTION_TYPE_ACTIVE_UNLOCK = 8,
  NP_FFI_ACTION_TYPE_NEARBY_SHARE = 9,
  NP_FFI_ACTION_TYPE_INSTANT_TETHERING = 10,
  NP_FFI_ACTION_TYPE_PHONE_HUB = 11,
};
typedef uint8_t np_ffi_ActionType;

/**
 * Result type for trying to add a V0 credential to a credential-slab.
 */
enum np_ffi_AddV0CredentialToSlabResult {
  /**
   * We succeeded in adding the credential to the slab.
   */
  NP_FFI_ADD_V0_CREDENTIAL_TO_SLAB_RESULT_SUCCESS = 0,
  /**
   * The handle to the slab was actually invalid.
   */
  NP_FFI_ADD_V0_CREDENTIAL_TO_SLAB_RESULT_INVALID_HANDLE = 1,
};
typedef uint8_t np_ffi_AddV0CredentialToSlabResult;

/**
 * Result code for the operation of adding a DE to a V0
 * advertisement builder.
 */
enum np_ffi_AddV0DEResult {
  /**
   * The DE was successfully added to the advertisement builder
   * behind the given handle.
   */
  NP_FFI_ADD_V0DE_RESULT_SUCCESS = 0,
  /**
   * The handle for the advertisement builder was invalid.
   */
  NP_FFI_ADD_V0DE_RESULT_INVALID_ADVERTISEMENT_BUILDER_HANDLE = 1,
  /**
   * There was not enough available space left in the advertisement
   * to append the given data element.
   */
  NP_FFI_ADD_V0DE_RESULT_INSUFFICIENT_ADVERTISEMENT_SPACE = 2,
  /**
   * The passed data element is not broadcastable under the
   * identity type of the advertisement (public/private).
   */
  NP_FFI_ADD_V0DE_RESULT_INVALID_IDENTITY_TYPE_FOR_DATA_ELEMENT = 3,
};
typedef uint8_t np_ffi_AddV0DEResult;

/**
 * Result type for trying to add a V1 credential to a credential-slab.
 */
enum np_ffi_AddV1CredentialToSlabResult {
  /**
   * We succeeded in adding the credential to the slab.
   */
  NP_FFI_ADD_V1_CREDENTIAL_TO_SLAB_RESULT_SUCCESS = 0,
  /**
   * The handle to the slab was actually invalid.
   */
  NP_FFI_ADD_V1_CREDENTIAL_TO_SLAB_RESULT_INVALID_HANDLE = 1,
  /**
   * The provided public key bytes do not actually represent a valid "edwards y" format
   * or that said compressed point is not actually a point on the curve.
   */
  NP_FFI_ADD_V1_CREDENTIAL_TO_SLAB_RESULT_INVALID_PUBLIC_KEY_BYTES = 2,
};
typedef uint8_t np_ffi_AddV1CredentialToSlabResult;

/**
 * Result code for operations adding DEs to a section builder.
 */
enum np_ffi_AddV1DEResult {
  /**
   * The DE was successfully added to the section builder
   * behind the given handle.
   */
  NP_FFI_ADD_V1DE_RESULT_SUCCESS = 0,
  /**
   * The handle for the section builder was invalid.
   */
  NP_FFI_ADD_V1DE_RESULT_INVALID_SECTION_HANDLE = 1,
  /**
   * There was no more space left in the advertisement
   * to fit the DE in the containing section.
   */
  NP_FFI_ADD_V1DE_RESULT_INSUFFICIENT_SECTION_SPACE = 2,
  /**
   * The data element itself had invalid characteristics,
   * most likely a length above 127.
   */
  NP_FFI_ADD_V1DE_RESULT_INVALID_DATA_ELEMENT = 3,
};
typedef uint8_t np_ffi_AddV1DEResult;

/**
 * Result code for [`V1SectionBuilder#add_to_advertisement`].
 */
enum np_ffi_AddV1SectionToAdvertisementResult {
  /**
   * The section referenced by the given handle
   * couldn't be added to the containing advertisement,
   * possibly because the handle is invalid or the section
   * has already been added to the containing section.
   */
  NP_FFI_ADD_V1_SECTION_TO_ADVERTISEMENT_RESULT_ERROR = 0,
  /**
   * The section referenced by the given handle
   * was successfully added to the containing advertisement.
   * After obtaining this result code, the section
   * handle will no longer be valid.
   */
  NP_FFI_ADD_V1_SECTION_TO_ADVERTISEMENT_RESULT_SUCCESS = 1,
};
typedef uint8_t np_ffi_AddV1SectionToAdvertisementResult;

/**
 * Enum common to V0 and V1 serialization expressing
 * what kind of advertisement builder (public/encrypted)
 * is in use.
 */
enum np_ffi_AdvertisementBuilderKind {
  /**
   * The builder is for a public advertisement.
   */
  NP_FFI_ADVERTISEMENT_BUILDER_KIND_PUBLIC = 0,
  /**
   * The builder is for an encrypted advertisement.
   */
  NP_FFI_ADVERTISEMENT_BUILDER_KIND_ENCRYPTED = 1,
};
typedef uint8_t np_ffi_AdvertisementBuilderKind;

/**
 * Discriminant for `BuildTxPowerResult`.
 */
enum np_ffi_BuildTxPowerResultKind {
  /**
   * The transmission power was outside the
   * allowed -100dBm to 20dBm range.
   */
  NP_FFI_BUILD_TX_POWER_RESULT_KIND_OUT_OF_RANGE = 0,
  /**
   * The transmission power was in range,
   * and so a `TxPower` struct was constructed.
   */
  NP_FFI_BUILD_TX_POWER_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_BuildTxPowerResultKind;

/**
 * Discriminant for `CreateCredentialBookResult`
 */
enum np_ffi_CreateCredentialBookResultKind {
  /**
   * We created a new credential book behind the given handle.
   * The associated payload may be obtained via
   * `CreateCredentialBookResult#into_success()`.
   */
  NP_FFI_CREATE_CREDENTIAL_BOOK_RESULT_KIND_SUCCESS = 0,
  /**
   * The slab that we tried to create a credential-book from
   * actually was an invalid handle.
   */
  NP_FFI_CREATE_CREDENTIAL_BOOK_RESULT_KIND_INVALID_SLAB_HANDLE = 1,
};
typedef uint8_t np_ffi_CreateCredentialBookResultKind;

/**
 * Discriminant for `CreateV1SectionBuilderResult`
 */
enum np_ffi_CreateV1SectionBuilderResultKind {
  /**
   * The attempt to create a new section builder succeeded.
   */
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_KIND_SUCCESS = 0,
  /**
   * We're currently in the middle of building a section.
   */
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_KIND_UNCLOSED_ACTIVE_SECTION = 1,
  /**
   * The advertisement builder handle was invalid.
   */
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_KIND_INVALID_ADVERTISEMENT_BUILDER_HANDLE = 2,
  /**
   * We're attempting to build a section with an identity
   * kind (public/encrypted) which doesn't match the kind
   * for the entire advertisement.
   */
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_KIND_IDENTITY_KIND_MISMATCH = 3,
  /**
   * There isn't enough space for a new section, either
   * because the maximum section count has been exceeded
   * or because the advertisement is almost full, and
   * the minimum size of a section wouldn't fit.
   */
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_KIND_NO_SPACE_LEFT = 4,
};
typedef uint8_t np_ffi_CreateV1SectionBuilderResultKind;

/**
 * A result-type enum which tells the caller whether/not a deallocation
 * succeeded or failed due to the requested handle not being present.
 */
typedef enum {
  /**
   * The requested handle to deallocate was not present in the map
   */
  NP_FFI_DEALLOCATE_RESULT_NOT_PRESENT = 1,
  /**
   * The object behind the handle was successfully deallocated
   */
  NP_FFI_DEALLOCATE_RESULT_SUCCESS = 2,
} np_ffi_DeallocateResult;

/**
 * Discriminant for `DecryptMetadataResult`.
 */
enum np_ffi_DecryptMetadataResultKind {
  /**
   * The attempt to decrypt the metadata of the associated credential succeeded
   * The associated payload may be obtained via
   * `DecryptMetadataResult#into_success`.
   */
  NP_FFI_DECRYPT_METADATA_RESULT_KIND_SUCCESS,
  /**
   * The attempt to decrypt the metadata failed, either the payload had no matching identity
   * ie it was a public advertisement OR the decrypt attempt itself was unsuccessful
   */
  NP_FFI_DECRYPT_METADATA_RESULT_KIND_ERROR,
};
typedef uint8_t np_ffi_DecryptMetadataResultKind;

/**
 * Discriminant for `DeserializeAdvertisementResult`.
 */
enum np_ffi_DeserializeAdvertisementResultKind {
  /**
   * Deserializing the advertisement failed, for some reason or another.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_KIND_ERROR = 0,
  /**
   * The advertisement was correctly deserialized, and it's a V0 advertisement.
   * `DeserializeAdvertisementResult#into_v0()` is the corresponding cast
   * to the associated enum variant.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_KIND_V0 = 1,
  /**
   * The advertisement was correctly deserialized, and it's a V1 advertisement.
   * `DeserializeAdvertisementResult#into_v1()` is the corresponding cast
   * to the associated enum variant.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_KIND_V1 = 2,
};
typedef uint8_t np_ffi_DeserializeAdvertisementResultKind;

/**
 * Discriminant for possible results of V0 advertisement deserialization
 */
enum np_ffi_DeserializedV0AdvertisementKind {
  /**
   * The deserialized V0 advertisement was legible.
   * The associated payload may be obtained via
   * `DeserializedV0Advertisement#into_legible`.
   */
  NP_FFI_DESERIALIZED_V0_ADVERTISEMENT_KIND_LEGIBLE = 1,
  /**
   * The deserialized V0 advertisement is illegible,
   * likely meaning that the receiver does not hold
   * the proper credentials to be able to read
   * the received advertisement.
   */
  NP_FFI_DESERIALIZED_V0_ADVERTISEMENT_KIND_NO_MATCHING_CREDENTIALS = 2,
};
typedef uint8_t np_ffi_DeserializedV0AdvertisementKind;

/**
 * Discriminant for deserialized information about the V0
 * identity utilized by a deserialized V0 advertisement.
 */
enum np_ffi_DeserializedV0IdentityKind {
  /**
   * The deserialized identity was a plaintext identity.
   */
  NP_FFI_DESERIALIZED_V0_IDENTITY_KIND_PLAINTEXT = 1,
  /**
   * The deserialized identity was some decrypted identity.
   */
  NP_FFI_DESERIALIZED_V0_IDENTITY_KIND_DECRYPTED = 2,
};
typedef uint8_t np_ffi_DeserializedV0IdentityKind;

/**
 * Discriminant for `DeserializedV1Identity`.
 */
enum np_ffi_DeserializedV1IdentityKind {
  /**
   * The deserialized v1 identity was plaintext
   */
  NP_FFI_DESERIALIZED_V1_IDENTITY_KIND_PLAINTEXT = 0,
  /**
   * The deserialized v1 identity corresponded
   * to some kind of decrypted identity.
   */
  NP_FFI_DESERIALIZED_V1_IDENTITY_KIND_DECRYPTED = 1,
};
typedef uint8_t np_ffi_DeserializedV1IdentityKind;

enum np_ffi_GetMetadataBufferPartsResultKind {
  NP_FFI_GET_METADATA_BUFFER_PARTS_RESULT_KIND_SUCCESS = 0,
  NP_FFI_GET_METADATA_BUFFER_PARTS_RESULT_KIND_ERROR = 1,
};
typedef uint8_t np_ffi_GetMetadataBufferPartsResultKind;

/**
 * Discriminant of `GetV0DEResult`.
 */
enum np_ffi_GetV0DEResultKind {
  /**
   * The attempt to get the DE succeeded.
   * The associated payload may be obtained via
   * `GetV0DEResult#into_success`.
   */
  NP_FFI_GET_V0DE_RESULT_KIND_SUCCESS = 0,
  /**
   * The attempt to get the DE failed,
   * possibly due to the requested index being
   * out-of-bounds or due to the advertisement
   * having been previously deallocated.
   */
  NP_FFI_GET_V0DE_RESULT_KIND_ERROR = 1,
};
typedef uint8_t np_ffi_GetV0DEResultKind;

/**
 * Discriminant for `GetV0IdentityDetailsResult`
 */
enum np_ffi_GetV0IdentityDetailsResultKind {
  /**
   * The attempt to get the identity details
   * for the advertisement failed, possibly
   * due to the advertisement being a public
   * advertisement, or the underlying
   * advertisement has already been deallocated.
   */
  NP_FFI_GET_V0_IDENTITY_DETAILS_RESULT_KIND_ERROR = 0,
  /**
   * The attempt to get the identity details succeeded.
   * The wrapped identity details may be obtained via
   * `GetV0IdentityDetailsResult#into_success`.
   */
  NP_FFI_GET_V0_IDENTITY_DETAILS_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_GetV0IdentityDetailsResultKind;

/**
 * Discriminant for `GetV1DE16ByteSaltResult`.
 */
enum np_ffi_GetV1DE16ByteSaltResultKind {
  /**
   * The attempt to get the derived salt failed, possibly
   * because the passed DE offset was invalid (==255),
   * or because there was no salt included for the
   * referenced advertisement section (i.e: it was
   * a public advertisement section, or it was deallocated.)
   */
  NP_FFI_GET_V1DE16_BYTE_SALT_RESULT_KIND_ERROR = 0,
  /**
   * A 16-byte salt for the given DE offset was successfully
   * derived.
   */
  NP_FFI_GET_V1DE16_BYTE_SALT_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_GetV1DE16ByteSaltResultKind;

/**
 * Discriminant for the `GetV1DEResult` enum.
 */
enum np_ffi_GetV1DEResultKind {
  /**
   * Attempting to get the DE at the given position failed,
   * possibly due to the index being out-of-bounds or due
   * to the whole advertisement having been previously deallocated.
   */
  NP_FFI_GET_V1DE_RESULT_KIND_ERROR = 0,
  /**
   * Attempting to get the DE at the given position succeeded.
   * The underlying DE may be extracted with `GetV1DEResult#into_success`.
   */
  NP_FFI_GET_V1DE_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_GetV1DEResultKind;

/**
 * Discriminant for `GetV1IdentityDetailsResult`
 */
enum np_ffi_GetV1IdentityDetailsResultKind {
  /**
   * The attempt to get the identity details
   * for the section failed, possibly
   * due to the section being a public
   * section, or the underlying
   * advertisement has already been deallocated.
   */
  NP_FFI_GET_V1_IDENTITY_DETAILS_RESULT_KIND_ERROR = 0,
  /**
   * The attempt to get the identity details succeeded.
   * The wrapped identity details may be obtained via
   * `GetV1IdentityDetailsResult#into_success`.
   */
  NP_FFI_GET_V1_IDENTITY_DETAILS_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_GetV1IdentityDetailsResultKind;

/**
 * Discriminant for `GetV1SectionResult`
 */
enum np_ffi_GetV1SectionResultKind {
  /**
   * The attempt to get the section failed,
   * possibly due to the section index being
   * out-of-bounds or due to the underlying
   * advertisement having already been deallocated.
   */
  NP_FFI_GET_V1_SECTION_RESULT_KIND_ERROR = 0,
  /**
   * The attempt to get the section succeeded.
   * The wrapped section may be obtained via
   * `GetV1SectionResult#into_success`.
   */
  NP_FFI_GET_V1_SECTION_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_GetV1SectionResultKind;

/**
 * Discriminant for `NextV1DE16ByteSaltResult`.
 */
enum np_ffi_NextV1DE16ByteSaltResultKind {
  /**
   * We couldn't return a 16-byte DE salt, possibly
   * because the handle to the section builder
   * was invalid, or possibly because the section
   * builder was for a public section.
   */
  NP_FFI_NEXT_V1DE16_BYTE_SALT_RESULT_KIND_ERROR = 0,
  /**
   * A 16-byte DE salt was returned successfully.
   */
  NP_FFI_NEXT_V1DE16_BYTE_SALT_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_NextV1DE16ByteSaltResultKind;

/**
 * Structure for categorized reasons for why a NP C FFI call may
 * be panicking.
 */
enum np_ffi_PanicReason {
  /**
   * Some enum cast to a variant failed. Utilized
   * for failed enum casts of all enums.
   *
   * (That is, this is the catch-all panic reason for enum
   * casts where there is not a more specific reason
   * in some other variant of this enum.)
   */
  NP_FFI_PANIC_REASON_ENUM_CAST_FAILED = 0,
  /**
   * The panic handler is used to assert conditions are true to avoid programmer errors.
   * If a failed assert condition is hit, this panic handler is invoked with this reason.
   */
  NP_FFI_PANIC_REASON_ASSERT_FAILED = 1,
  /**
   * Error returned if the bit representation of a supposedly-Rust-constructed
   * -and-validated type actually doesn't correspond to the format of the
   * data structure expected on the Rust side of the boundary, and performing
   * further operations on the structure would yield unintended behavior.
   * If this kind of error is being raised, the C code must
   * be messing with stack-allocated data structures for this library
   * in an entirely unexpected way.
   */
  NP_FFI_PANIC_REASON_INVALID_STACK_DATA_STRUCTURE = 2,
  /**
   * The maximum amount of allocations per type is `u32::MAX`, this panic handler is invoked
   * with this reason when this is exceeded. Clients should never need more than 4 Billions
   * handles and would certainly run into other issues before reaching that point
   */
  NP_FFI_PANIC_REASON_EXCEEDED_MAX_HANDLE_ALLOCATIONS = 3,
};
typedef uint8_t np_ffi_PanicReason;

/**
 * Discriminant for `SerializeV0AdvertisementResult`.
 */
enum np_ffi_SerializeV0AdvertisementResultKind {
  /**
   * Serializing the advertisement to bytes was successful.
   */
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_KIND_SUCCESS = 0,
  /**
   * The advertisement builder handle was invalid.
   */
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_KIND_INVALID_ADVERTISEMENT_BUILDER_HANDLE = 1,
  /**
   * Serializing the advertisement to bytes failed
   * because the data in the advertisement wasn't
   * of an appropriate size for LDT encryption
   * to succeed.
   */
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_KIND_LDT_ERROR = 2,
  /**
   * Serializing an unencrypted adv failed because the adv data didn't meet the length
   * requirements.
   */
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_KIND_UNENCRYPTED_ERROR = 3,
};
typedef uint8_t np_ffi_SerializeV0AdvertisementResultKind;

/**
 * Discriminant for `SerializeV1AdvertisementResult`.
 */
enum np_ffi_SerializeV1AdvertisementResultKind {
  /**
   * Serializing the advertisement to bytes was successful.
   */
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_KIND_SUCCESS = 0,
  /**
   * The state of the advertisement builder was invalid
   * for the builder to be closed for serialization, likely
   * because there was an unclosed section builder.
   */
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_KIND_INVALID_BUILDER_STATE = 1,
  /**
   * The advertisement builder handle was invalid.
   */
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_KIND_INVALID_ADVERTISEMENT_BUILDER_HANDLE = 2,
};
typedef uint8_t np_ffi_SerializeV1AdvertisementResultKind;

/**
 * Discriminant for `SetV0ActionResult`.
 */
enum np_ffi_SetV0ActionResultKind {
  /**
   * The attempt to set the action bit failed. The
   * action bits were yielded back to the caller,
   * unmodified.
   */
  NP_FFI_SET_V0_ACTION_RESULT_KIND_ERROR = 0,
  /**
   * The attempt to set the action bit succeeded.
   * The updated action bits were yielded back to the caller.
   */
  NP_FFI_SET_V0_ACTION_RESULT_KIND_SUCCESS = 1,
};
typedef uint8_t np_ffi_SetV0ActionResultKind;

/**
 * Discriminant for `V0DataElement`.
 */
enum np_ffi_V0DataElementKind {
  /**
   * A transmission Power (Tx Power) data-element.
   * The associated payload may be obtained via
   * `V0DataElement#into_tx_power`.
   */
  NP_FFI_V0_DATA_ELEMENT_KIND_TX_POWER = 1,
  /**
   * The Actions data-element.
   * The associated payload may be obtained via
   * `V0DataElement#into_actions`.
   */
  NP_FFI_V0_DATA_ELEMENT_KIND_ACTIONS = 2,
};
typedef uint8_t np_ffi_V0DataElementKind;

/**
 * Information about the verification scheme used
 * for verifying the integrity of the contents
 * of a decrypted section.
 */
enum np_ffi_V1VerificationMode {
  /**
   * Message integrity code verification.
   */
  NP_FFI_V1_VERIFICATION_MODE_MIC = 0,
  /**
   * Signature verification.
   */
  NP_FFI_V1_VERIFICATION_MODE_SIGNATURE = 1,
};
typedef uint8_t np_ffi_V1VerificationMode;

/**
 * Holds the count of handles currently allocated for each handle type
 */
typedef struct {
  uint32_t cred_book;
  uint32_t cred_slab;
  uint32_t decrypted_metadata;
  uint32_t v0_payload;
  uint32_t legible_v1_sections;
  uint32_t v0_advertisement_builder;
  uint32_t v1_advertisement_builder;
} np_ffi_CurrentHandleAllocations;

/**
 * A `#[repr(C)]` handle to a value of type `CredentialBookInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_CredentialBook;

/**
 * Result type for `create_credential_book`
 */
enum np_ffi_CreateCredentialBookResult_Tag {
  NP_FFI_CREATE_CREDENTIAL_BOOK_RESULT_SUCCESS = 0,
  NP_FFI_CREATE_CREDENTIAL_BOOK_RESULT_INVALID_SLAB_HANDLE = 2,
};
typedef uint8_t np_ffi_CreateCredentialBookResult_Tag;

typedef union {
  np_ffi_CreateCredentialBookResult_Tag tag;
  struct {
    np_ffi_CreateCredentialBookResult_Tag success_tag;
    np_ffi_CredentialBook success;
  };
} np_ffi_CreateCredentialBookResult;

/**
 * A `#[repr(C)]` handle to a value of type `CredentialSlabInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_CredentialSlab;

/**
 * Cryptographic information about a particular V0 discovery credential
 * necessary to match and decrypt encrypted V0 advertisements.
 */
typedef struct {
  uint8_t key_seed[32];
  uint8_t identity_token_hmac[32];
} np_ffi_V0DiscoveryCredential;

/**
 * A representation of a MatchedCredential which is passable across the FFI boundary
 */
typedef struct {
  int64_t cred_id;
  const uint8_t *encrypted_metadata_bytes_buffer;
  uintptr_t encrypted_metadata_bytes_len;
} np_ffi_FfiMatchedCredential;

/**
 * Representation of a V0 credential that contains additional data to provide back to caller once it
 * is matched. The credential_id can be used by the caller to correlate it back to the full
 * credentials details.
 */
typedef struct {
  np_ffi_V0DiscoveryCredential discovery_cred;
  np_ffi_FfiMatchedCredential matched_cred;
} np_ffi_V0MatchableCredential;

/**
 * Cryptographic information about a particular V1 discovery credential
 * necessary to match and decrypt encrypted V1 advertisement sections.
 */
typedef struct {
  uint8_t key_seed[32];
  uint8_t expected_mic_short_salt_identity_token_hmac[32];
  uint8_t expected_mic_extended_salt_identity_token_hmac[32];
  uint8_t expected_signature_identity_token_hmac[32];
  uint8_t pub_key[32];
} np_ffi_V1DiscoveryCredential;

/**
 * Representation of a V1 credential that contains additional data to provide back to caller once it
 * is matched. The credential_id can be used by the caller to correlate it back to the full
 * credentials details.
 */
typedef struct {
  np_ffi_V1DiscoveryCredential discovery_cred;
  np_ffi_FfiMatchedCredential matched_cred;
} np_ffi_V1MatchableCredential;

/**
 * A `#[repr(C)]` handle to a value of type `DecryptedMetadataInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_DecryptedMetadata;

/**
 * The result of decrypting metadata from either a V0Payload or DeserializedV1Section
 */
typedef enum {
  NP_FFI_DECRYPT_METADATA_RESULT_SUCCESS,
  NP_FFI_DECRYPT_METADATA_RESULT_ERROR,
} np_ffi_DecryptMetadataResult_Tag;

typedef struct {
  np_ffi_DecryptMetadataResult_Tag tag;
  union {
    struct {
      np_ffi_DecryptedMetadata success;
    };
  };
} np_ffi_DecryptMetadataResult;

/**
 * The pointer and length of the decrypted metadata byte buffer
 */
typedef struct {
  const uint8_t *ptr;
  uintptr_t len;
} np_ffi_MetadataBufferParts;

typedef enum {
  NP_FFI_GET_METADATA_BUFFER_PARTS_RESULT_SUCCESS,
  NP_FFI_GET_METADATA_BUFFER_PARTS_RESULT_ERROR,
} np_ffi_GetMetadataBufferPartsResult_Tag;

typedef struct {
  np_ffi_GetMetadataBufferPartsResult_Tag tag;
  union {
    struct {
      np_ffi_MetadataBufferParts success;
    };
  };
} np_ffi_GetMetadataBufferPartsResult;

/**
 * A `#[repr(C)]` handle to a value of type `V0PayloadInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_V0Payload;

/**
 * Represents a deserialized V0 advertisement whose DE contents may be read
 */
typedef struct {
  uint8_t num_des;
  np_ffi_V0Payload payload;
  np_ffi_DeserializedV0IdentityKind identity_kind;
} np_ffi_LegibleDeserializedV0Advertisement;

/**
 * Represents a deserialized V0 advertisement
 */
typedef enum {
  NP_FFI_DESERIALIZED_V0_ADVERTISEMENT_LEGIBLE,
  NP_FFI_DESERIALIZED_V0_ADVERTISEMENT_NO_MATCHING_CREDENTIALS,
} np_ffi_DeserializedV0Advertisement_Tag;

typedef struct {
  np_ffi_DeserializedV0Advertisement_Tag tag;
  union {
    struct {
      np_ffi_LegibleDeserializedV0Advertisement legible;
    };
  };
} np_ffi_DeserializedV0Advertisement;

/**
 * A `#[repr(C)]` handle to a value of type `LegibleV1SectionsInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_LegibleV1Sections;

/**
 * Representation of a deserialized V1 advertisement
 */
typedef struct {
  /**
   * The number of legible sections
   */
  uint8_t num_legible_sections;
  /**
   * The number of sections that were unable to be decrypted
   */
  uint8_t num_undecryptable_sections;
  /**
   * A handle to the set of legible (plain or decrypted) sections
   */
  np_ffi_LegibleV1Sections legible_sections;
} np_ffi_DeserializedV1Advertisement;

/**
 * The result of calling `np_ffi_deserialize_advertisement`.
 * Must be explicitly deallocated after use with
 * a corresponding `np_ffi_deallocate_deserialize_advertisement_result`
 */
enum np_ffi_DeserializeAdvertisementResult_Tag {
  /**
   * Deserializing the advertisement failed, for some reason or another.
   * `DeserializeAdvertisementResultKind::Error` is the associated enum tag.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_ERROR,
  /**
   * The advertisement was correctly deserialized, and it's a V0 advertisement.
   * `DeserializeAdvertisementResultKind::V0` is the associated enum tag.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_V0,
  /**
   * The advertisement was correctly deserialized, and it's a V1 advertisement.
   * `DeserializeAdvertisementResultKind::V1` is the associated enum tag.
   */
  NP_FFI_DESERIALIZE_ADVERTISEMENT_RESULT_V1,
};
typedef uint8_t np_ffi_DeserializeAdvertisementResult_Tag;

typedef union {
  np_ffi_DeserializeAdvertisementResult_Tag tag;
  struct {
    np_ffi_DeserializeAdvertisementResult_Tag v0_tag;
    np_ffi_DeserializedV0Advertisement v0;
  };
  struct {
    np_ffi_DeserializeAdvertisementResult_Tag v1_tag;
    np_ffi_DeserializedV1Advertisement v1;
  };
} np_ffi_DeserializeAdvertisementResult;

/**
 * A byte-string with a maximum size of N,
 * where only the first `len` bytes are considered
 * to contain the actual payload. N is only
 * permitted to be between 0 and 255.
 */
typedef struct {
  uint8_t len;
  uint8_t bytes[255];
} np_ffi_ByteBuffer_255;

/**
 * Represents the raw contents of the service payload data
 * under the Nearby Presence service UUID
 */
typedef struct {
  np_ffi_ByteBuffer_255 bytes;
} np_ffi_RawAdvertisementPayload;

/**
 * Representation of a transmission power,
 * as used for the Tx Power DE in V0 and V1.
 */
typedef struct {
  int8_t tx_power;
} np_ffi_TxPower;

/**
 * The bitfield data of a V0Actions data element
 */
typedef struct {
  uint32_t bitfield;
} np_ffi_V0ActionBits;

/**
 * Representation of the Actions DE in V0.
 */
typedef enum {
  /**
   * A set of action bits which were present in a plaintext identity advertisement
   */
  NP_FFI_V0_ACTIONS_PLAINTEXT,
  /**
   * A set of action bits which were present in a encrypted identity advertisement
   */
  NP_FFI_V0_ACTIONS_ENCRYPTED,
} np_ffi_V0Actions_Tag;

typedef struct {
  np_ffi_V0Actions_Tag tag;
  union {
    struct {
      np_ffi_V0ActionBits plaintext;
    };
    struct {
      np_ffi_V0ActionBits encrypted;
    };
  };
} np_ffi_V0Actions;

/**
 * Representation of a V0 data element.
 */
typedef enum {
  NP_FFI_V0_DATA_ELEMENT_TX_POWER,
  NP_FFI_V0_DATA_ELEMENT_ACTIONS,
} np_ffi_V0DataElement_Tag;

typedef struct {
  np_ffi_V0DataElement_Tag tag;
  union {
    struct {
      np_ffi_TxPower tx_power;
    };
    struct {
      np_ffi_V0Actions actions;
    };
  };
} np_ffi_V0DataElement;

/**
 * The result of `V0Payload#get_de`.
 */
typedef enum {
  NP_FFI_GET_V0DE_RESULT_SUCCESS,
  NP_FFI_GET_V0DE_RESULT_ERROR,
} np_ffi_GetV0DEResult_Tag;

typedef struct {
  np_ffi_GetV0DEResult_Tag tag;
  union {
    struct {
      np_ffi_V0DataElement success;
    };
  };
} np_ffi_GetV0DEResult;

/**
 * Information about the identity which matched a
 * decrypted V0 advertisement.
 */
typedef struct {
  /**
   * The ID of the credential which
   * matched the deserialized adv
   */
  int64_t cred_id;
  /**
   * The 14-byte legacy identity token
   */
  uint8_t identity_token[14];
  /**
   * The 2-byte advertisement salt
   */
  uint8_t salt[2];
} np_ffi_DeserializedV0IdentityDetails;

/**
 * The result of attempting to get the identity details
 * for a V0 advertisement via
 * `DeserializedV0Advertisement#get_identity_details`.
 */
typedef enum {
  NP_FFI_GET_V0_IDENTITY_DETAILS_RESULT_ERROR,
  NP_FFI_GET_V0_IDENTITY_DETAILS_RESULT_SUCCESS,
} np_ffi_GetV0IdentityDetailsResult_Tag;

typedef struct {
  np_ffi_GetV0IdentityDetailsResult_Tag tag;
  union {
    struct {
      np_ffi_DeserializedV0IdentityDetails success;
    };
  };
} np_ffi_GetV0IdentityDetailsResult;

/**
 * Handle to a deserialized V1 section
 */
typedef struct {
  np_ffi_LegibleV1Sections legible_sections_handle;
  uint8_t legible_section_index;
  uint8_t num_des;
  np_ffi_DeserializedV1IdentityKind identity_tag;
} np_ffi_DeserializedV1Section;

/**
 * The result of attempting to get a particular V1 section
 * from its' index within the list of legible sections
 * via `DeserializedV1Advertisement::get_section`.
 */
typedef enum {
  NP_FFI_GET_V1_SECTION_RESULT_ERROR,
  NP_FFI_GET_V1_SECTION_RESULT_SUCCESS,
} np_ffi_GetV1SectionResult_Tag;

typedef struct {
  np_ffi_GetV1SectionResult_Tag tag;
  union {
    struct {
      np_ffi_DeserializedV1Section success;
    };
  };
} np_ffi_GetV1SectionResult;

/**
 * Representation of the data-element type tag
 * of a V1 data element.
 */
typedef struct {
  uint32_t code;
} np_ffi_V1DEType;

/**
 * A byte-string with a maximum size of N,
 * where only the first `len` bytes are considered
 * to contain the actual payload. N is only
 * permitted to be between 0 and 255.
 */
typedef struct {
  uint8_t len;
  uint8_t bytes[127];
} np_ffi_ByteBuffer_127;

/**
 * FFI-transmissible representation of a generic V1 data-element.
 * This representation is stable, and so you may directly
 * reference this struct's fields if you wish.
 */
typedef struct {
  /**
   * The offset of this generic data-element.
   */
  uint8_t offset;
  /**
   * The DE type code of this generic data-element.
   */
  np_ffi_V1DEType de_type;
  /**
   * The raw data-element byte payload, up to
   * 127 bytes in length.
   */
  np_ffi_ByteBuffer_127 payload;
} np_ffi_GenericV1DataElement;

/**
 * FFI-transmissible representation of a V1 data-element
 */
typedef enum {
  /**
   * A "generic" V1 data-element, for which we have no
   * particular information about its schema (just
   * a DE type code and a byte payload.)
   */
  NP_FFI_V1_DATA_ELEMENT_GENERIC,
} np_ffi_V1DataElement_Tag;

typedef struct {
  np_ffi_V1DataElement_Tag tag;
  union {
    struct {
      np_ffi_GenericV1DataElement generic;
    };
  };
} np_ffi_V1DataElement;

/**
 * Represents the result of the `DeserializedV1Section#get_de` operation.
 */
typedef enum {
  NP_FFI_GET_V1DE_RESULT_ERROR,
  NP_FFI_GET_V1DE_RESULT_SUCCESS,
} np_ffi_GetV1DEResult_Tag;

typedef struct {
  np_ffi_GetV1DEResult_Tag tag;
  union {
    struct {
      np_ffi_V1DataElement success;
    };
  };
} np_ffi_GetV1DEResult;

/**
 * Information about the identity which matched
 * a decrypted V1 section.
 */
typedef struct {
  /**
   * The verification mode (MIC/Signature) which
   * was used to verify the decrypted adv contents.
   */
  np_ffi_V1VerificationMode verification_mode;
  /**
   * The ID of the credential which
   * matched the deserialized section.
   */
  int64_t cred_id;
  /**
   * The 16-byte metadata key.
   */
  uint8_t identity_token[16];
} np_ffi_DeserializedV1IdentityDetails;

/**
 * The result of attempting to get the identity details
 * for a V1 advertisement section via
 * `DeserializedV1Advertisement#get_identity_details`.
 */
typedef enum {
  NP_FFI_GET_V1_IDENTITY_DETAILS_RESULT_ERROR,
  NP_FFI_GET_V1_IDENTITY_DETAILS_RESULT_SUCCESS,
} np_ffi_GetV1IdentityDetailsResult_Tag;

typedef struct {
  np_ffi_GetV1IdentityDetailsResult_Tag tag;
  union {
    struct {
      np_ffi_DeserializedV1IdentityDetails success;
    };
  };
} np_ffi_GetV1IdentityDetailsResult;

/**
 * A FFI safe wrapper of a fixed size array
 */
typedef struct {
  uint8_t _0[16];
} np_ffi_FixedSizeArray_16;

/**
 * The result of attempting to get a derived 16-byte salt
 * for a given DE within a section.
 */
typedef enum {
  NP_FFI_GET_V1DE16_BYTE_SALT_RESULT_ERROR,
  NP_FFI_GET_V1DE16_BYTE_SALT_RESULT_SUCCESS,
} np_ffi_GetV1DE16ByteSaltResult_Tag;

typedef struct {
  np_ffi_GetV1DE16ByteSaltResult_Tag tag;
  union {
    struct {
      np_ffi_FixedSizeArray_16 success;
    };
  };
} np_ffi_GetV1DE16ByteSaltResult;

/**
 * A `#[repr(C)]` handle to a value of type `V0AdvertisementBuilderInternals`
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_V0AdvertisementBuilder;

/**
 * A byte-string with a maximum size of N,
 * where only the first `len` bytes are considered
 * to contain the actual payload. N is only
 * permitted to be between 0 and 255.
 */
typedef struct {
  uint8_t len;
  uint8_t bytes[24];
} np_ffi_ByteBuffer_24;

/**
 * The result of attempting to serialize the contents
 * of a V0 advertisement builder to raw bytes.
 */
typedef enum {
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_SUCCESS,
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_INVALID_ADVERTISEMENT_BUILDER_HANDLE,
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_LDT_ERROR,
  NP_FFI_SERIALIZE_V0_ADVERTISEMENT_RESULT_UNENCRYPTED_ERROR,
} np_ffi_SerializeV0AdvertisementResult_Tag;

typedef struct {
  np_ffi_SerializeV0AdvertisementResult_Tag tag;
  union {
    struct {
      np_ffi_ByteBuffer_24 success;
    };
  };
} np_ffi_SerializeV0AdvertisementResult;

/**
 * Cryptographic information about a particular V0 broadcast credential
 * necessary to LDT-encrypt V0 advertisements.
 */
typedef struct {
  uint8_t key_seed[32];
  uint8_t identity_token[14];
} np_ffi_V0BroadcastCredential;

/**
 * A FFI safe wrapper of a fixed size array
 */
typedef struct {
  uint8_t _0[2];
} np_ffi_FixedSizeArray_2;

/**
 * A handle to a builder for V1 advertisements.
 */
typedef struct {
  uint64_t handle_id;
} np_ffi_V1AdvertisementBuilder;

/**
 * A handle to a builder for V1 sections. This is not a unique handle; it is the same handle as
 * the advertisement builder the section builder was originated from.
 */
typedef struct {
  /**
   * The parent advertisement builder for this section
   */
  np_ffi_V1AdvertisementBuilder adv_builder;
  /**
   * This section's index in the parent advertisement
   */
  uint8_t section_index;
} np_ffi_V1SectionBuilder;

/**
 * The result of attempting to create a new V1 section builder.
 */
typedef enum {
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_SUCCESS,
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_UNCLOSED_ACTIVE_SECTION,
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_INVALID_ADVERTISEMENT_BUILDER_HANDLE,
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_IDENTITY_KIND_MISMATCH,
  NP_FFI_CREATE_V1_SECTION_BUILDER_RESULT_NO_SPACE_LEFT,
} np_ffi_CreateV1SectionBuilderResult_Tag;

typedef struct {
  np_ffi_CreateV1SectionBuilderResult_Tag tag;
  union {
    struct {
      np_ffi_V1SectionBuilder success;
    };
  };
} np_ffi_CreateV1SectionBuilderResult;

/**
 * Cryptographic information about a particular V1 broadcast credential
 * necessary to encrypt V1 MIC-verified and signature-verified sections.
 */
typedef struct {
  uint8_t key_seed[32];
  uint8_t identity_token[16];
  uint8_t private_key[32];
} np_ffi_V1BroadcastCredential;

/**
 * A byte-string with a maximum size of N,
 * where only the first `len` bytes are considered
 * to contain the actual payload. N is only
 * permitted to be between 0 and 255.
 */
typedef struct {
  uint8_t len;
  uint8_t bytes[250];
} np_ffi_ByteBuffer_250;

/**
 * The result of attempting to serialize the contents
 * of a V1 advertisement builder to raw bytes.
 */
typedef enum {
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_SUCCESS,
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_INVALID_BUILDER_STATE,
  NP_FFI_SERIALIZE_V1_ADVERTISEMENT_RESULT_INVALID_ADVERTISEMENT_BUILDER_HANDLE,
} np_ffi_SerializeV1AdvertisementResult_Tag;

typedef struct {
  np_ffi_SerializeV1AdvertisementResult_Tag tag;
  union {
    struct {
      np_ffi_ByteBuffer_250 success;
    };
  };
} np_ffi_SerializeV1AdvertisementResult;

/**
 * The result of attempting to get the derived V1 DE
 * 16-byte salt for the next-added DE to the section
 * builder behind the given handle.
 */
typedef enum {
  NP_FFI_NEXT_V1DE16_BYTE_SALT_RESULT_ERROR,
  NP_FFI_NEXT_V1DE16_BYTE_SALT_RESULT_SUCCESS,
} np_ffi_NextV1DE16ByteSaltResult_Tag;

typedef struct {
  np_ffi_NextV1DE16ByteSaltResult_Tag tag;
  union {
    struct {
      np_ffi_FixedSizeArray_16 success;
    };
  };
} np_ffi_NextV1DE16ByteSaltResult;

/**
 * Represents the contents of a V1 DE whose payload
 * is stored in a buffer which may contain up to 127 bytes,
 * which is the maximum for any V1 DE.
 *
 * This representation is stable, and so you may directly
 * reference this struct's fields if you wish.
 */
typedef struct {
  /**
   * The DE type code of this generic data-element.
   */
  uint32_t de_type;
  /**
   * The raw data-element byte payload, up to
   * 127 bytes in length.
   */
  np_ffi_ByteBuffer_127 payload;
} np_ffi_V1DE127ByteBuffer;

/**
 * Result type for attempting to construct a
 * Tx Power from a signed byte.
 */
typedef enum {
  NP_FFI_BUILD_TX_POWER_RESULT_OUT_OF_RANGE,
  NP_FFI_BUILD_TX_POWER_RESULT_SUCCESS,
} np_ffi_BuildTxPowerResult_Tag;

typedef struct {
  np_ffi_BuildTxPowerResult_Tag tag;
  union {
    struct {
      np_ffi_TxPower success;
    };
  };
} np_ffi_BuildTxPowerResult;

/**
 * The result of attempting to set a particular action
 * bit on some `V0Actions`.
 */
typedef enum {
  NP_FFI_SET_V0_ACTION_RESULT_SUCCESS,
  NP_FFI_SET_V0_ACTION_RESULT_ERROR,
} np_ffi_SetV0ActionResult_Tag;

typedef struct {
  np_ffi_SetV0ActionResult_Tag tag;
  union {
    struct {
      np_ffi_V0Actions success;
    };
    struct {
      np_ffi_V0Actions error;
    };
  };
} np_ffi_SetV0ActionResult;

/**
 * Overrides the global panic handler to be used when NP C FFI calls panic.
 * This method will only have an effect on the global panic-handler
 * the first time it's called, and this method will return `true`
 * to indicate that the panic handler was successfully set.
 * All subsequent calls to this method
 * will simply ignore the argument and return `false`.
 *
 * If the passed function pointer is non-null,
 * then we will call it upon every panic,
 * followed by the default panicking behavior for
 * the platform (in the case where the user-specified
 * function does not terminate or hang the running process.)
 *
 * Otherwise, we will resort to the
 * default panicking behavior for the system, which
 * is a printed stack trace followed by an abort
 * when this crate is compiled with `std`,
 * but a bare `loop { }` when this crate is compiled without.
 */
bool np_ffi_global_config_panic_handler(void (*handler)(np_ffi_PanicReason));

/**
 * Checks the current count of all outstanding handle allocations, useful for debugging,
 * logging, and testing
 */
np_ffi_CurrentHandleAllocations np_ffi_global_config_get_current_allocation_count(void);

/**
 * Sets an override to the number of shards to employ in the NP FFI's
 * internal handle-maps, which places an upper bound on the number
 * of writing threads which may make progress at any one time
 * when concurrently accessing handles of the same type.
 *
 * By default, this value will be set to 16, or in `std` environments,
 * the minimum of 16 and the number of available hardware threads.
 * A shard value override of zero will be interpreted the same
 * as this default.
 *
 * Setting this value will have no effect if the handle-maps for the
 * API have already begun being used by the client code, and any
 * values set will take effect upon the first usage of _any_ non-`np_ffi_global_config_set`
 * API call.
 */
void np_ffi_global_config_set_num_shards(uint8_t num_shards);

/**
 * Allocates a new credential-book from the given slab, returning a handle
 * to the created object. The slab will be deallocated by this call.
 */
np_ffi_CreateCredentialBookResult np_ffi_create_credential_book_from_slab(np_ffi_CredentialSlab slab);

/**
 * Gets the tag of a `CreateCredentialBookResult` tagged enum.
 */
np_ffi_CreateCredentialBookResultKind np_ffi_CreateCredentialBookResult_kind(np_ffi_CreateCredentialBookResult result);

/**
 * Casts a `CreateCredentialBookResult` to the `SUCCESS` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_CredentialBook np_ffi_CreateCredentialBookResult_into_SUCCESS(np_ffi_CreateCredentialBookResult result);

/**
 * Deallocates a credential-slab by its handle.
 */
np_ffi_DeallocateResult np_ffi_deallocate_credential_slab(np_ffi_CredentialSlab credential_slab);

/**
 * Deallocates a credential-book by its handle
 */
np_ffi_DeallocateResult np_ffi_deallocate_credential_book(np_ffi_CredentialBook credential_book);

/**
 * Allocates a new credential-slab, returning a handle to the created object
 */
np_ffi_CredentialSlab np_ffi_create_credential_slab(void);

/**
 * Adds the given V0 discovery credential with some associated
 * match-data to this credential slab.
 *
 * Safety: this is safe if the provided pointer points to a valid memory address
 * which contains the correct len amount of bytes. The copy from the memory address isn't atomic,
 * so concurrent modification of the array from another thread would cause undefined behavior.
 */
np_ffi_AddV0CredentialToSlabResult np_ffi_CredentialSlab_add_v0_credential(np_ffi_CredentialSlab credential_slab,
                                                                           np_ffi_V0MatchableCredential v0_cred);

/**
 * Adds the given V1 discovery credential with some associated
 * match-data to this credential slab.
 *
 * Safety: this is safe if the provided pointer points to a valid memory address
 * which contains the correct len amount of bytes. The copy from the memory address isn't atomic,
 * so concurrent modification of the array from another thread would cause undefined behavior.
 */
np_ffi_AddV1CredentialToSlabResult np_ffi_CredentialSlab_add_v1_credential(np_ffi_CredentialSlab credential_slab,
                                                                           np_ffi_V1MatchableCredential v1_cred);

/**
 * Frees the underlying resources of the decrypted metadata buffer
 */
np_ffi_DeallocateResult np_ffi_deallocate_DecryptedMetadata(np_ffi_DecryptedMetadata metadata);

/**
 * Gets the tag of a `DecryptMetadataResult` tagged-union. On success the wrapped identity
 * details may be obtained via `DecryptMetadataResult#into_success`.
 */
np_ffi_DecryptMetadataResultKind np_ffi_DecryptMetadataResult_kind(np_ffi_DecryptMetadataResult result);

/**
 * Casts a `DecryptMetadataResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DecryptedMetadata np_ffi_DecryptMetadataResult_into_SUCCESS(np_ffi_DecryptMetadataResult result);

/**
 * Gets the pointer and length of the heap allocated byte buffer of decrypted metadata
 */
np_ffi_GetMetadataBufferPartsResult np_ffi_DecryptedMetadata_get_metadata_buffer_parts(np_ffi_DecryptedMetadata metadata);

/**
 * Gets the tag of a `GetMetadataBufferPartsResult` tagged-union. On success the wrapped identity
 * details may be obtained via `GetMetadataBufferPartsResult#into_success`.
 */
np_ffi_GetMetadataBufferPartsResultKind np_ffi_GetMetadataBufferPartsResult_kind(np_ffi_GetMetadataBufferPartsResult result);

/**
 * Casts a `GetMetadataBufferPartsResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant. This returns the pointer and length
 * of the byte buffer containing the decrypted metadata.  There can be a data-race between attempts
 * to access the contents of the buffer and attempts to free the handle from different threads.
 */
np_ffi_MetadataBufferParts np_ffi_GetMetadataBufferPartsResult_into_SUCCESS(np_ffi_GetMetadataBufferPartsResult result);

/**
 * Attempts to deserialize an advertisement with the given service-data
 * payload (presumed to be under the NP service UUID) using credentials
 * pulled from the given credential-book.
 */
np_ffi_DeserializeAdvertisementResult np_ffi_deserialize_advertisement(np_ffi_RawAdvertisementPayload adv_payload,
                                                                       np_ffi_CredentialBook credential_book);

/**
 * Gets the tag of a `DeserializeAdvertisementResult` tagged-union.
 */
np_ffi_DeserializeAdvertisementResultKind np_ffi_DeserializeAdvertisementResult_kind(np_ffi_DeserializeAdvertisementResult result);

/**
 * Casts a `DeserializeAdvertisementResult` to the `V0` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DeserializedV0Advertisement np_ffi_DeserializeAdvertisementResult_into_V0(np_ffi_DeserializeAdvertisementResult result);

/**
 * Casts a `DeserializeAdvertisementResult` to the `V1` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DeserializedV1Advertisement np_ffi_DeserializeAdvertisementResult_into_V1(np_ffi_DeserializeAdvertisementResult result);

/**
 * Deallocates any internal data referenced by a `DeserializeAdvertisementResult`. This should only
 * be used if into_V0 or into_V1, have not been called yet as it shares the same underlying
 * resource.
 */
np_ffi_DeallocateResult np_ffi_deallocate_deserialize_advertisement_result(np_ffi_DeserializeAdvertisementResult result);

/**
 * Deallocates any internal data referenced by a `DeserializedV0Advertisement`
 */
np_ffi_DeallocateResult np_ffi_deallocate_deserialized_V0_advertisement(np_ffi_DeserializedV0Advertisement adv);

/**
 * Deallocates any internal data referenced by a `DeserializedV1Advertisement`
 */
np_ffi_DeallocateResult np_ffi_deallocate_deserialized_V1_advertisement(np_ffi_DeserializedV1Advertisement adv);

/**
 * Gets the tag of a `DeserializedV0Advertisement` tagged-union.
 */
np_ffi_DeserializedV0AdvertisementKind np_ffi_DeserializedV0Advertisement_kind(np_ffi_DeserializedV0Advertisement result);

/**
 * Casts a `DeserializedV0Advertisement` to the `Legible` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_LegibleDeserializedV0Advertisement np_ffi_DeserializedV0Advertisement_into_LEGIBLE(np_ffi_DeserializedV0Advertisement adv);

/**
 * Gets the number of DEs in a legible deserialized advertisement.
 * Suitable as an iteration bound for `V0Payload#get_de`.
 */
uint8_t np_ffi_LegibleDeserializedV0Advertisement_get_num_des(np_ffi_LegibleDeserializedV0Advertisement adv);

/**
 * Gets just the data-element payload of a `LegibleDeserializedV0Advertisement`.
 */
np_ffi_V0Payload np_ffi_LegibleDeserializedV0Advertisement_into_payload(np_ffi_LegibleDeserializedV0Advertisement adv);

/**
 * Gets just the identity kind associated with a `LegibleDeserializedV0Advertisement`.
 */
np_ffi_DeserializedV0IdentityKind np_ffi_LegibleDeserializedV0Advertisement_get_identity_kind(np_ffi_LegibleDeserializedV0Advertisement adv);

/**
 * Deallocates any internal data of a `LegibleDeserializedV0Advertisement`
 */
np_ffi_DeallocateResult np_ffi_deallocate_legible_v0_advertisement(np_ffi_LegibleDeserializedV0Advertisement adv);

/**
 * Attempts to get the data-element with the given index in the passed v0 adv payload
 */
np_ffi_GetV0DEResult np_ffi_V0Payload_get_de(np_ffi_V0Payload payload, uint8_t index);

/**
 * Attempts to decrypt the metadata for the matched credential for this V0 payload (if any)
 */
np_ffi_DecryptMetadataResult np_ffi_V0Payload_decrypt_metadata(np_ffi_V0Payload payload);

/**
 * Gets the identity details for this V0 payload, or returns an error if this payload does not have
 * any associated identity (public advertisement)
 */
np_ffi_GetV0IdentityDetailsResult np_ffi_V0Payload_get_identity_details(np_ffi_V0Payload payload);

/**
 * Gets the tag of a `GetV0IdentityDetailsResult` tagged-union. On success the wrapped identity
 * details may be obtained via `GetV0IdentityDetailsResult#into_success`.
 */
np_ffi_GetV0IdentityDetailsResultKind np_ffi_GetV0IdentityDetailsResult_kind(np_ffi_GetV0IdentityDetailsResult result);

/**
 * Casts a `GetV0IdentityDetailsResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DeserializedV0IdentityDetails np_ffi_GetV0IdentityDetailsResult_into_SUCCESS(np_ffi_GetV0IdentityDetailsResult result);

/**
 * Deallocates any internal data of a `V0Payload`
 */
np_ffi_DeallocateResult np_ffi_deallocate_v0_payload(np_ffi_V0Payload payload);

/**
 * Gets the tag of a `GetV0DEResult` tagged-union.
 */
np_ffi_GetV0DEResultKind np_ffi_GetV0DEResult_kind(np_ffi_GetV0DEResult result);

/**
 * Casts a `GetV0DEResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_V0DataElement np_ffi_GetV0DEResult_into_SUCCESS(np_ffi_GetV0DEResult result);

/**
 * Gets the number of legible sections on a deserialized V1 advertisement.
 * Suitable as an index bound for the second argument of
 * `np_ffi_DeserializedV1Advertisement#get_section`.
 */
uint8_t np_ffi_DeserializedV1Advertisement_get_num_legible_sections(np_ffi_DeserializedV1Advertisement adv);

/**
 * Gets the number of sections on a deserialized V1 advertisement which
 * were unable to be decrypted with the credentials that the receiver possesses.
 */
uint8_t np_ffi_DeserializedV1Advertisement_get_num_undecryptable_sections(np_ffi_DeserializedV1Advertisement adv);

/**
 * Gets the legible section with the given index in a deserialized V1 advertisement.
 */
np_ffi_GetV1SectionResult np_ffi_DeserializedV1Advertisement_get_section(np_ffi_DeserializedV1Advertisement adv,
                                                                         uint8_t legible_section_index);

/**
 * Gets the tag of the `GetV1SectionResult` tagged-union.
 */
np_ffi_GetV1SectionResultKind np_ffi_GetV1SectionResult_kind(np_ffi_GetV1SectionResult result);

/**
 * Casts a `GetV1SectionResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DeserializedV1Section np_ffi_GetV1SectionResult_into_SUCCESS(np_ffi_GetV1SectionResult result);

/**
 * Gets the number of data elements in a deserialized v1 section.
 * Suitable as an iteration bound for the second argument of
 * `np_ffi_DeserializedV1Section_get_de`.
 */
uint8_t np_ffi_DeserializedV1Section_get_num_des(np_ffi_DeserializedV1Section section);

/**
 * Gets the tag of the identity tagged-union used for the passed section.
 */
np_ffi_DeserializedV1IdentityKind np_ffi_DeserializedV1Section_get_identity_kind(np_ffi_DeserializedV1Section section);

/**
 * Gets the data-element with the given index in the passed section.
 */
np_ffi_GetV1DEResult np_ffi_DeserializedV1Section_get_de(np_ffi_DeserializedV1Section section,
                                                         uint8_t de_index);

/**
 * Gets the identity details used to decrypt this V1 section, or returns an error if this payload
 * does not have any associated identity (public advertisement)
 */
np_ffi_GetV1IdentityDetailsResult np_ffi_DeserializedV1Section_get_identity_details(np_ffi_DeserializedV1Section section);

/**
 * Gets the tag of a `GetV1IdentityDetailsResult` tagged-union. On success the wrapped identity
 * details may be obtained via `GetV0IdentityDetailsResult#into_success`.
 */
np_ffi_GetV1IdentityDetailsResultKind np_ffi_GetV1IdentityDetailsResult_kind(np_ffi_GetV1IdentityDetailsResult result);

/**
 * Casts a `GetV1IdentityDetailsResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_DeserializedV1IdentityDetails np_ffi_GetV1IdentityDetailsResult_into_SUCCESS(np_ffi_GetV1IdentityDetailsResult result);

/**
 * Attempts to decrypt the metadata for the matched credential for this V0 payload (if any)
 */
np_ffi_DecryptMetadataResult np_ffi_DeserializedV1Section_decrypt_metadata(np_ffi_DeserializedV1Section section);

/**
 * Attempts to derive a 16-byte DE salt for a DE in this section with the given DE offset. This
 * operation may fail if the passed offset is 255 (causes overflow) or if the section
 * is leveraging a public identity, and hence, doesn't have an associated salt.
 */
np_ffi_GetV1DE16ByteSaltResult np_ffi_DeserializedV1Section_derive_16_byte_salt_for_offset(np_ffi_DeserializedV1Section section,
                                                                                           uint8_t offset);

/**
 * Gets the tag of a `GetV1DE16ByteSaltResult` tagged-union. On success the wrapped identity
 * details may be obtained via `GetV1DE16ByteSaltResult#into_success`.
 */
np_ffi_GetV1DE16ByteSaltResultKind np_ffi_GetV1DE16ByteSaltResult_kind(np_ffi_GetV1DE16ByteSaltResult result);

/**
 * Casts a `GetV1DE16ByteSaltResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_FixedSizeArray_16 np_ffi_GetV1DE16ByteSaltResult_into_SUCCESS(np_ffi_GetV1DE16ByteSaltResult result);

/**
 * Gets the tag of the `GetV1DEResult` tagged-union.
 */
np_ffi_GetV1DEResultKind np_ffi_GetV1DEResult_kind(np_ffi_GetV1DEResult result);

/**
 * Casts a `GetV1DEResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_V1DataElement np_ffi_GetV1DEResult_into_SUCCESS(np_ffi_GetV1DEResult result);

/**
 * Attempts to add the given data element to the V0
 * advertisement builder behind the passed handle.
 *
 * This method may invoke the panic handler if the passed DE
 * has an invalid layout, which may indicate that the backing
 * data on the stack was somehow tampered with in an unintended way.
 */
np_ffi_AddV0DEResult np_ffi_V0AdvertisementBuilder_add_de(np_ffi_V0AdvertisementBuilder adv_builder,
                                                          np_ffi_V0DataElement de);

/**
 * Attempts to serialize the contents of the advertisement builder
 * behind this handle to bytes. Assuming that the handle is valid,
 * this operation will always result in the contents behind the
 * advertisement builder handle being deallocated.
 */
np_ffi_SerializeV0AdvertisementResult np_ffi_V0AdvertisementBuilder_into_advertisement(np_ffi_V0AdvertisementBuilder adv_builder);

/**
 * Attempts to deallocate the v0 advertisement builder behind
 * the given handle.
 */
np_ffi_DeallocateResult np_ffi_deallocate_v0_advertisement_builder(np_ffi_V0AdvertisementBuilder adv_builder);

/**
 * Creates a new V0 advertisement builder for a public advertisement.
 */
np_ffi_V0AdvertisementBuilder np_ffi_create_v0_public_advertisement_builder(void);

/**
 * Creates a new V0 advertisement builder for an encrypted advertisement.
 */
np_ffi_V0AdvertisementBuilder np_ffi_create_v0_encrypted_advertisement_builder(np_ffi_V0BroadcastCredential broadcast_cred,
                                                                               np_ffi_FixedSizeArray_2 salt);

/**
 * Gets the tag of a `SerializeV0AdvertisementResult` tagged-union.
 */
np_ffi_SerializeV0AdvertisementResultKind np_ffi_SerializeV0AdvertisementResult_kind(np_ffi_SerializeV0AdvertisementResult result);

/**
 * Casts a `SerializeV0AdvertisementResult` to the `Success` variant,
 * panicking in the case where the passed value is of a different enum variant.
 */
np_ffi_ByteBuffer_24 np_ffi_SerializeV0AdvertisementResult_into_SUCCESS(np_ffi_SerializeV0AdvertisementResult result);

/**
 * Attempts to create a builder for a new public section within
 * the advertisement builder behind this handle,
 * returning a handle to the newly-created section builder if successful.
 *
 * This method may fail if there is another currently-active
 * section builder for the same advertisement builder, if the
 * kind of section being added does not match the advertisement
 * type (public/encrypted), or if the section would not manage
 * to fit within the enclosing advertisement.
 */
np_ffi_CreateV1SectionBuilderResult np_ffi_V1AdvertisementBuilder_public_section_builder(np_ffi_V1AdvertisementBuilder adv_builder);

/**
 * Attempts to create a builder for a new encrypted section within
 * the advertisement builder behind the given handle,
 * returning a handle to the newly-created section builder if successful.
 *
 * The identity details for the new section builder may be specified
 * via providing the broadcast credential data, the kind of encrypted
 * identity being broadcast (private/trusted/provisioned), and the
 * verification mode (MIC/Signature) to be used for the encrypted section.
 *
 * This method may fail if there is another currently-active
 * section builder for the same advertisement builder, if the
 * kind of section being added does not match the advertisement
 * type (public/encrypted), or if the section would not manage
 * to fit within the enclosing advertisement.
 */
np_ffi_CreateV1SectionBuilderResult np_ffi_V1AdvertisementBuilder_encrypted_section_builder(np_ffi_V1AdvertisementBuilder adv_builder,
                                                                                            np_ffi_V1BroadcastCredential broadcast_cred,
                                                                                            np_ffi_V1VerificationMode verification_mode);

/**
 * Attempts to serialize the contents of the advertisement builder
 * behind this handle to bytes. Assuming that the handle is valid,
 * this operation will always result in the contents behind the
 * advertisement builder handle being deallocated.
 */
np_ffi_SerializeV1AdvertisementResult np_ffi_V1AdvertisementBuilder_into_advertisement(np_ffi_V1AdvertisementBuilder adv_builder);

/**
 * Creates a new V1 advertisement builder for the given advertisement
 * kind (public/encrypted).
 */
np_ffi_V1AdvertisementBuilder np_ffi_create_v1_advertisement_builder(np_ffi_AdvertisementBuilderKind kind);

/**
 * Gets the tag of a `SerializeV1AdvertisementResult` tagged-union.
 */
np_ffi_SerializeV1AdvertisementResultKind np_ffi_SerializeV1AdvertisementResult_kind(np_ffi_SerializeV1AdvertisementResult result);

/**
 * Casts a `SerializeV1AdvertisementResult` to the `Success` variant,
 * panicking in the case where the passed value is of a different enum variant.
 */
np_ffi_ByteBuffer_250 np_ffi_SerializeV1AdvertisementResult_into_SUCCESS(np_ffi_SerializeV1AdvertisementResult result);

/**
 * Gets the tag of a `CreateV1SectionBuilderResult` tagged-union.
 */
np_ffi_CreateV1SectionBuilderResultKind np_ffi_CreateV1SectionBuilderResult_kind(np_ffi_CreateV1SectionBuilderResult result);

/**
 * Casts a `CreateV1SectionBuilderResult` to the `Success` variant,
 * panicking in the case where the passed value is of a different enum variant.
 */
np_ffi_V1SectionBuilder np_ffi_CreateV1SectionBuilderResult_into_SUCCESS(np_ffi_CreateV1SectionBuilderResult result);

/**
 * Gets the tag of a `NextV1DE16ByteSaltResult` tagged-union.
 */
np_ffi_NextV1DE16ByteSaltResultKind np_ffi_NextV1DE16ByteSaltResult_kind(np_ffi_NextV1DE16ByteSaltResult result);

/**
 * Casts a `NextV1DE16ByteSaltResult` to the `Success` variant,
 * panicking in the case where the passed value is of a different enum variant.
 */
np_ffi_FixedSizeArray_16 np_ffi_NextV1DE16ByteSaltResult_into_SUCCESS(np_ffi_NextV1DE16ByteSaltResult result);

/**
 * Adds the section constructed behind the given handle to
 * a section builder to the containing advertisement it originated from.
 * After this call, the section builder handle will become invalid.
 */
np_ffi_AddV1SectionToAdvertisementResult np_ffi_V1SectionBuilder_add_to_advertisement(np_ffi_V1SectionBuilder section_builder);

/**
 * Attempts to get the derived 16-byte V1 DE salt for the next
 * DE to be added to the passed section builder. May fail if this
 * section builder handle is invalid, or if the section
 * is a public section.
 */
np_ffi_NextV1DE16ByteSaltResult np_ffi_V1SectionBuilder_next_de_salt(np_ffi_V1SectionBuilder section_builder);

/**
 * Attempts to add the given DE to the section builder behind
 * this handle. The passed DE may have a payload of up to 127
 * bytes, the maximum for a V1 DE.
 */
np_ffi_AddV1DEResult np_ffi_V1SectionBuilder_add_127_byte_buffer_de(np_ffi_V1SectionBuilder section_builder,
                                                                    np_ffi_V1DE127ByteBuffer de);

/**
 * Gets the tag of a `V0DataElement` tagged-union.
 */
np_ffi_V0DataElementKind np_ffi_V0DataElement_kind(np_ffi_V0DataElement de);

/**
 * Casts a `V0DataElement` to the `TxPower` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_TxPower np_ffi_V0DataElement_into_TX_POWER(np_ffi_V0DataElement de);

/**
 * Upcasts a Tx power DE to a generic V0 data-element.
 */
np_ffi_V0DataElement np_ffi_TxPower_into_V0DataElement(np_ffi_TxPower tx_power);

/**
 * Casts a `V0DataElement` to the `Actions` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_V0Actions np_ffi_V0DataElement_into_ACTIONS(np_ffi_V0DataElement de);

/**
 * Upcasts a V0 actions DE to a generic V0 data-element.
 */
np_ffi_V0DataElement np_ffi_V0Actions_into_V0DataElement(np_ffi_V0Actions actions);

/**
 * Gets the tag of a `BuildTxPowerResult` tagged-union.
 */
np_ffi_BuildTxPowerResultKind np_ffi_BuildTxPowerResult_kind(np_ffi_BuildTxPowerResult result);

/**
 * Casts a `BuildTxPowerResult` to the `Success` variant, panicking in the
 * case where the passed value is of a different enum variant.
 */
np_ffi_TxPower np_ffi_BuildTxPowerResult_into_SUCCESS(np_ffi_BuildTxPowerResult result);

/**
 * Attempts to construct a new TxPower from
 * the given signed-byte value.
 */
np_ffi_BuildTxPowerResult np_ffi_TxPower_build_from_signed_byte(int8_t tx_power);

/**
 * Gets the value of the given TxPower as a signed byte.
 */
int8_t np_ffi_TxPower_as_signed_byte(np_ffi_TxPower tx_power);

/**
 * Gets the discriminant of the `SetV0ActionResult` tagged-union.
 */
np_ffi_SetV0ActionResultKind np_ffi_SetV0ActionResult_kind(np_ffi_SetV0ActionResult result);

/**
 * Attempts to cast a `SetV0ActionResult` tagged-union into the `Success` variant.
 */
np_ffi_V0Actions np_ffi_SetV0ActionResult_into_SUCCESS(np_ffi_SetV0ActionResult result);

/**
 * Attempts to cast a `SetV0ActionResult` tagged-union into the `Error` variant.
 */
np_ffi_V0Actions np_ffi_SetV0ActionResult_into_ERROR(np_ffi_SetV0ActionResult result);

/**
 * Constructs a new V0 actions DE with no declared boolean
 * actions and a zeroed context sync sequence number,
 * where the DE is intended for the given advertisement
 * kind (plaintext/encrypted).
 */
np_ffi_V0Actions np_ffi_build_new_zeroed_V0Actions(np_ffi_AdvertisementBuilderKind kind);

/**
 * Return whether a boolean action type is set in this data element
 */
bool np_ffi_V0Actions_has_action(np_ffi_V0Actions actions, np_ffi_ActionType action_type);

/**
 * Attempts to set the given action bit to the given boolean value.
 * This operation may fail if the requested action bit may not be
 * set for the kind of containing advertisement (public/encrypted)
 * that this action DE is intended to belong to. In this case,
 * the original action bits will be yielded back to the caller,
 * unaltered.
 */
np_ffi_SetV0ActionResult np_ffi_V0Actions_set_action(np_ffi_V0Actions actions,
                                                     np_ffi_ActionType action_type,
                                                     bool value);

/**
 * Returns the representation of the passed `V0Actions` as an unsigned
 * integer, where the bit-positions correspond to individual actions.
 */
uint32_t np_ffi_V0Actions_as_u32(np_ffi_V0Actions actions);

/**
 * Converts a `V1DataElement` to a `GenericV1DataElement` which
 * only maintains information about the DE's type-code and payload.
 */
np_ffi_GenericV1DataElement np_ffi_V1DataElement_to_generic(np_ffi_V1DataElement de);

/**
 * Extracts the numerical value of the given V1 DE type code as
 * an unsigned 32-bit integer.
 */
uint32_t np_ffi_V1DEType_to_uint32_t(np_ffi_V1DEType de_type);

// clang-format on
