/*
 Copyright 2023 Google LLC
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

// clang-format off


#pragma once

/* Generated with cbindgen:0.26.0 */

/*
 WARNING: this file is autogenerated by cbindgen. Don't modify this manually.
 Additionally, you should _not_ rely upon the layouts of the generated
 structs and unions if you want your code to be forward-compatible,
 unless a given type explicitly states in its documentation that it has
 a guaranteed forward-compatible layout.
 Instead, you should use _only_ the provided exported function symbols.
*/

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace np_ffi {
namespace internal {

/// The possible boolean action types which can be present in an Actions data element
enum class ActionType : uint8_t {
  CrossDevSdk = 1,
  CallTransfer = 4,
  ActiveUnlock = 8,
  NearbyShare = 9,
  InstantTethering = 10,
  PhoneHub = 11,
};

/// Result type for trying to add a V0 credential to a credential-slab.
enum class AddV0CredentialToSlabResult : uint8_t {
  /// We succeeded in adding the credential to the slab.
  Success = 0,
  /// The handle to the slab was actually invalid.
  InvalidHandle = 1,
};

/// Result code for the operation of adding a DE to a V0
/// advertisement builder.
enum class AddV0DEResult : uint8_t {
  /// The DE was successfully added to the advertisement builder
  /// behind the given handle.
  Success = 0,
  /// The handle for the advertisement builder was invalid.
  InvalidAdvertisementBuilderHandle = 1,
  /// There was not enough available space left in the advertisement
  /// to append the given data element.
  InsufficientAdvertisementSpace = 2,
  /// The passed data element is not broadcastable under the
  /// identity type of the advertisement (public/private).
  InvalidIdentityTypeForDataElement = 3,
};

/// Result type for trying to add a V1 credential to a credential-slab.
enum class AddV1CredentialToSlabResult : uint8_t {
  /// We succeeded in adding the credential to the slab.
  Success = 0,
  /// The handle to the slab was actually invalid.
  InvalidHandle = 1,
  /// The provided public key bytes do not actually represent a valid "edwards y" format
  /// or that said compressed point is not actually a point on the curve.
  InvalidPublicKeyBytes = 2,
};

/// Result code for operations adding DEs to a section builder.
enum class AddV1DEResult : uint8_t {
  /// The DE was successfully added to the section builder
  /// behind the given handle.
  Success = 0,
  /// The handle for the section builder was invalid.
  InvalidSectionHandle = 1,
  /// There was no more space left in the advertisement
  /// to fit the DE in the containing section.
  InsufficientSectionSpace = 2,
  /// The data element itself had invalid characteristics,
  /// most likely a length above 127.
  InvalidDataElement = 3,
};

/// Result code for [`V1SectionBuilder#add_to_advertisement`].
enum class AddV1SectionToAdvertisementResult : uint8_t {
  /// The section referenced by the given handle
  /// couldn't be added to the containing advertisement,
  /// possibly because the handle is invalid or the section
  /// has already been added to the containing section.
  Error = 0,
  /// The section referenced by the given handle
  /// was successfully added to the containing advertisement.
  /// After obtaining this result code, the section
  /// handle will no longer be valid.
  Success = 1,
};

/// Enum common to V0 and V1 serialization expressing
/// what kind of advertisement builder (public/encrypted)
/// is in use.
enum class AdvertisementBuilderKind : uint8_t {
  /// The builder is for a public advertisement.
  Public = 0,
  /// The builder is for an encrypted advertisement.
  Encrypted = 1,
};

/// Discriminant for `BuildTxPowerResult`.
enum class BuildTxPowerResultKind : uint8_t {
  /// The transmission power was outside the
  /// allowed -100dBm to 20dBm range.
  OutOfRange = 0,
  /// The transmission power was in range,
  /// and so a `TxPower` struct was constructed.
  Success = 1,
};

/// Discriminant for `CreateCredentialBookResult`
enum class CreateCredentialBookResultKind : uint8_t {
  /// We created a new credential book behind the given handle.
  /// The associated payload may be obtained via
  /// `CreateCredentialBookResult#into_success()`.
  Success = 0,
  /// The slab that we tried to create a credential-book from
  /// actually was an invalid handle.
  InvalidSlabHandle = 1,
};

/// Discriminant for `CreateV1SectionBuilderResult`
enum class CreateV1SectionBuilderResultKind : uint8_t {
  /// The attempt to create a new section builder succeeded.
  Success = 0,
  /// We're currently in the middle of building a section.
  UnclosedActiveSection = 1,
  /// The advertisement builder handle was invalid.
  InvalidAdvertisementBuilderHandle = 2,
  /// We're attempting to build a section with an identity
  /// kind (public/encrypted) which doesn't match the kind
  /// for the entire advertisement.
  IdentityKindMismatch = 3,
  /// There isn't enough space for a new section, either
  /// because the maximum section count has been exceeded
  /// or because the advertisement is almost full, and
  /// the minimum size of a section wouldn't fit.
  NoSpaceLeft = 4,
};

/// A result-type enum which tells the caller whether/not a deallocation
/// succeeded or failed due to the requested handle not being present.
enum class DeallocateResult {
  /// The requested handle to deallocate was not present in the map
  NotPresent = 1,
  /// The object behind the handle was successfully deallocated
  Success = 2,
};

/// Discriminant for `DecryptMetadataResult`.
enum class DecryptMetadataResultKind : uint8_t {
  /// The attempt to decrypt the metadata of the associated credential succeeded
  /// The associated payload may be obtained via
  /// `DecryptMetadataResult#into_success`.
  Success,
  /// The attempt to decrypt the metadata failed, either the payload had no matching identity
  /// ie it was a public advertisement OR the decrypt attempt itself was unsuccessful
  Error,
};

/// Discriminant for `DeserializeAdvertisementResult`.
enum class DeserializeAdvertisementResultKind : uint8_t {
  /// Deserializing the advertisement failed, for some reason or another.
  Error = 0,
  /// The advertisement was correctly deserialized, and it's a V0 advertisement.
  /// `DeserializeAdvertisementResult#into_v0()` is the corresponding cast
  /// to the associated enum variant.
  V0 = 1,
  /// The advertisement was correctly deserialized, and it's a V1 advertisement.
  /// `DeserializeAdvertisementResult#into_v1()` is the corresponding cast
  /// to the associated enum variant.
  V1 = 2,
};

/// Discriminant for possible results of V0 advertisement deserialization
enum class DeserializedV0AdvertisementKind : uint8_t {
  /// The deserialized V0 advertisement was legible.
  /// The associated payload may be obtained via
  /// `DeserializedV0Advertisement#into_legible`.
  Legible = 1,
  /// The deserialized V0 advertisement is illegible,
  /// likely meaning that the receiver does not hold
  /// the proper credentials to be able to read
  /// the received advertisement.
  NoMatchingCredentials = 2,
};

/// Discriminant for deserialized information about the V0
/// identity utilized by a deserialized V0 advertisement.
enum class DeserializedV0IdentityKind : uint8_t {
  /// The deserialized identity was a plaintext identity.
  Plaintext = 1,
  /// The deserialized identity was some decrypted identity.
  Decrypted = 2,
};

/// Discriminant for `DeserializedV1Identity`.
enum class DeserializedV1IdentityKind : uint8_t {
  /// The deserialized v1 identity was plaintext
  Plaintext = 0,
  /// The deserialized v1 identity corresponded
  /// to some kind of decrypted identity.
  Decrypted = 1,
};

enum class GetMetadataBufferPartsResultKind : uint8_t {
  Success = 0,
  Error = 1,
};

/// Discriminant of `GetV0DEResult`.
enum class GetV0DEResultKind : uint8_t {
  /// The attempt to get the DE succeeded.
  /// The associated payload may be obtained via
  /// `GetV0DEResult#into_success`.
  Success = 0,
  /// The attempt to get the DE failed,
  /// possibly due to the requested index being
  /// out-of-bounds or due to the advertisement
  /// having been previously deallocated.
  Error = 1,
};

/// Discriminant for `GetV0IdentityDetailsResult`
enum class GetV0IdentityDetailsResultKind : uint8_t {
  /// The attempt to get the identity details
  /// for the advertisement failed, possibly
  /// due to the advertisement being a public
  /// advertisement, or the underlying
  /// advertisement has already been deallocated.
  Error = 0,
  /// The attempt to get the identity details succeeded.
  /// The wrapped identity details may be obtained via
  /// `GetV0IdentityDetailsResult#into_success`.
  Success = 1,
};

/// Discriminant for `GetV1DE16ByteSaltResult`.
enum class GetV1DE16ByteSaltResultKind : uint8_t {
  /// The attempt to get the derived salt failed, possibly
  /// because the passed DE offset was invalid (==255),
  /// or because there was no salt included for the
  /// referenced advertisement section (i.e: it was
  /// a public advertisement section, or it was deallocated.)
  Error = 0,
  /// A 16-byte salt for the given DE offset was successfully
  /// derived.
  Success = 1,
};

/// Discriminant for the `GetV1DEResult` enum.
enum class GetV1DEResultKind : uint8_t {
  /// Attempting to get the DE at the given position failed,
  /// possibly due to the index being out-of-bounds or due
  /// to the whole advertisement having been previously deallocated.
  Error = 0,
  /// Attempting to get the DE at the given position succeeded.
  /// The underlying DE may be extracted with `GetV1DEResult#into_success`.
  Success = 1,
};

/// Discriminant for `GetV1IdentityDetailsResult`
enum class GetV1IdentityDetailsResultKind : uint8_t {
  /// The attempt to get the identity details
  /// for the section failed, possibly
  /// due to the section being a public
  /// section, or the underlying
  /// advertisement has already been deallocated.
  Error = 0,
  /// The attempt to get the identity details succeeded.
  /// The wrapped identity details may be obtained via
  /// `GetV1IdentityDetailsResult#into_success`.
  Success = 1,
};

/// Discriminant for `GetV1SectionResult`
enum class GetV1SectionResultKind : uint8_t {
  /// The attempt to get the section failed,
  /// possibly due to the section index being
  /// out-of-bounds or due to the underlying
  /// advertisement having already been deallocated.
  Error = 0,
  /// The attempt to get the section succeeded.
  /// The wrapped section may be obtained via
  /// `GetV1SectionResult#into_success`.
  Success = 1,
};

/// Discriminant for `NextV1DE16ByteSaltResult`.
enum class NextV1DE16ByteSaltResultKind : uint8_t {
  /// We couldn't return a 16-byte DE salt, possibly
  /// because the handle to the section builder
  /// was invalid, or possibly because the section
  /// builder was for a public section.
  Error = 0,
  /// A 16-byte DE salt was returned successfully.
  Success = 1,
};

/// Structure for categorized reasons for why a NP C FFI call may
/// be panicking.
enum class PanicReason : uint8_t {
  /// Some enum cast to a variant failed. Utilized
  /// for failed enum casts of all enums.
  ///
  /// (That is, this is the catch-all panic reason for enum
  /// casts where there is not a more specific reason
  /// in some other variant of this enum.)
  EnumCastFailed = 0,
  /// The panic handler is used to assert conditions are true to avoid programmer errors.
  /// If a failed assert condition is hit, this panic handler is invoked with this reason.
  AssertFailed = 1,
  /// Error returned if the bit representation of a supposedly-Rust-constructed
  /// -and-validated type actually doesn't correspond to the format of the
  /// data structure expected on the Rust side of the boundary, and performing
  /// further operations on the structure would yield unintended behavior.
  /// If this kind of error is being raised, the C code must
  /// be messing with stack-allocated data structures for this library
  /// in an entirely unexpected way.
  InvalidStackDataStructure = 2,
  /// The maximum amount of allocations per type is `u32::MAX`, this panic handler is invoked
  /// with this reason when this is exceeded. Clients should never need more than 4 Billions
  /// handles and would certainly run into other issues before reaching that point
  ExceededMaxHandleAllocations = 3,
};

/// Discriminant for `SerializeV0AdvertisementResult`.
enum class SerializeV0AdvertisementResultKind : uint8_t {
  /// Serializing the advertisement to bytes was successful.
  Success = 0,
  /// The advertisement builder handle was invalid.
  InvalidAdvertisementBuilderHandle = 1,
  /// Serializing the advertisement to bytes failed
  /// because the data in the advertisement wasn't
  /// of an appropriate size for LDT encryption
  /// to succeed.
  LdtError = 2,
  /// Serializing an unencrypted adv failed because the adv data didn't meet the length
  /// requirements.
  UnencryptedError = 3,
};

/// Discriminant for `SerializeV1AdvertisementResult`.
enum class SerializeV1AdvertisementResultKind : uint8_t {
  /// Serializing the advertisement to bytes was successful.
  Success = 0,
  /// The state of the advertisement builder was invalid
  /// for the builder to be closed for serialization, likely
  /// because there was an unclosed section builder.
  InvalidBuilderState = 1,
  /// The advertisement builder handle was invalid.
  InvalidAdvertisementBuilderHandle = 2,
};

/// Discriminant for `SetV0ActionResult`.
enum class SetV0ActionResultKind : uint8_t {
  /// The attempt to set the action bit failed. The
  /// action bits were yielded back to the caller,
  /// unmodified.
  Error = 0,
  /// The attempt to set the action bit succeeded.
  /// The updated action bits were yielded back to the caller.
  Success = 1,
};

/// Discriminant for `V0DataElement`.
enum class V0DataElementKind : uint8_t {
  /// A transmission Power (Tx Power) data-element.
  /// The associated payload may be obtained via
  /// `V0DataElement#into_tx_power`.
  TxPower = 1,
  /// The Actions data-element.
  /// The associated payload may be obtained via
  /// `V0DataElement#into_actions`.
  Actions = 2,
};

/// Information about the verification scheme used
/// for verifying the integrity of the contents
/// of a decrypted section.
enum class V1VerificationMode : uint8_t {
  /// Message integrity code verification.
  Mic = 0,
  /// Signature verification.
  Signature = 1,
};

/// Holds the count of handles currently allocated for each handle type
struct CurrentHandleAllocations {
  uint32_t cred_book;
  uint32_t cred_slab;
  uint32_t decrypted_metadata;
  uint32_t v0_payload;
  uint32_t legible_v1_sections;
  uint32_t v0_advertisement_builder;
  uint32_t v1_advertisement_builder;
};

/// A `#[repr(C)]` handle to a value of type `CredentialBookInternals`
struct CredentialBook {
  uint64_t handle_id;
};

/// Result type for `create_credential_book`
union CreateCredentialBookResult {
  enum class Tag : uint8_t {
    Success = 0,
    InvalidSlabHandle = 2,
  };

  struct Success_Body {
    Tag tag;
    CredentialBook _0;
  };

  struct {
    Tag tag;
  };
  Success_Body success;
};

/// A `#[repr(C)]` handle to a value of type `CredentialSlabInternals`
struct CredentialSlab {
  uint64_t handle_id;
};

/// Cryptographic information about a particular V0 discovery credential
/// necessary to match and decrypt encrypted V0 advertisements.
struct V0DiscoveryCredential {
  uint8_t key_seed[32];
  uint8_t identity_token_hmac[32];
};

/// A representation of a MatchedCredential which is passable across the FFI boundary
struct FfiMatchedCredential {
  int64_t cred_id;
  const uint8_t *encrypted_metadata_bytes_buffer;
  uintptr_t encrypted_metadata_bytes_len;
};

/// Representation of a V0 credential that contains additional data to provide back to caller once it
/// is matched. The credential_id can be used by the caller to correlate it back to the full
/// credentials details.
struct V0MatchableCredential {
  V0DiscoveryCredential discovery_cred;
  FfiMatchedCredential matched_cred;
};

/// Cryptographic information about a particular V1 discovery credential
/// necessary to match and decrypt encrypted V1 advertisement sections.
struct V1DiscoveryCredential {
  uint8_t key_seed[32];
  uint8_t expected_mic_short_salt_identity_token_hmac[32];
  uint8_t expected_mic_extended_salt_identity_token_hmac[32];
  uint8_t expected_signature_identity_token_hmac[32];
  uint8_t pub_key[32];
};

/// Representation of a V1 credential that contains additional data to provide back to caller once it
/// is matched. The credential_id can be used by the caller to correlate it back to the full
/// credentials details.
struct V1MatchableCredential {
  V1DiscoveryCredential discovery_cred;
  FfiMatchedCredential matched_cred;
};

/// A `#[repr(C)]` handle to a value of type `DecryptedMetadataInternals`
struct DecryptedMetadata {
  uint64_t handle_id;
};

/// The result of decrypting metadata from either a V0Payload or DeserializedV1Section
struct DecryptMetadataResult {
  enum class Tag {
    Success,
    Error,
  };

  struct Success_Body {
    DecryptedMetadata _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// The pointer and length of the decrypted metadata byte buffer
struct MetadataBufferParts {
  const uint8_t *ptr;
  uintptr_t len;
};

struct GetMetadataBufferPartsResult {
  enum class Tag {
    Success,
    Error,
  };

  struct Success_Body {
    MetadataBufferParts _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// A `#[repr(C)]` handle to a value of type `V0PayloadInternals`
struct V0Payload {
  uint64_t handle_id;
};

/// Represents a deserialized V0 advertisement whose DE contents may be read
struct LegibleDeserializedV0Advertisement {
  uint8_t num_des;
  V0Payload payload;
  DeserializedV0IdentityKind identity_kind;
};

/// Represents a deserialized V0 advertisement
struct DeserializedV0Advertisement {
  enum class Tag {
    Legible,
    NoMatchingCredentials,
  };

  struct Legible_Body {
    LegibleDeserializedV0Advertisement _0;
  };

  Tag tag;
  union {
    Legible_Body legible;
  };
};

/// A `#[repr(C)]` handle to a value of type `LegibleV1SectionsInternals`
struct LegibleV1Sections {
  uint64_t handle_id;
};

/// Representation of a deserialized V1 advertisement
struct DeserializedV1Advertisement {
  /// The number of legible sections
  uint8_t num_legible_sections;
  /// The number of sections that were unable to be decrypted
  uint8_t num_undecryptable_sections;
  /// A handle to the set of legible (plain or decrypted) sections
  LegibleV1Sections legible_sections;
};

/// The result of calling `np_ffi_deserialize_advertisement`.
/// Must be explicitly deallocated after use with
/// a corresponding `np_ffi_deallocate_deserialize_advertisement_result`
union DeserializeAdvertisementResult {
  enum class Tag : uint8_t {
    /// Deserializing the advertisement failed, for some reason or another.
    /// `DeserializeAdvertisementResultKind::Error` is the associated enum tag.
    Error,
    /// The advertisement was correctly deserialized, and it's a V0 advertisement.
    /// `DeserializeAdvertisementResultKind::V0` is the associated enum tag.
    V0,
    /// The advertisement was correctly deserialized, and it's a V1 advertisement.
    /// `DeserializeAdvertisementResultKind::V1` is the associated enum tag.
    V1,
  };

  struct V0_Body {
    Tag tag;
    DeserializedV0Advertisement _0;
  };

  struct V1_Body {
    Tag tag;
    DeserializedV1Advertisement _0;
  };

  struct {
    Tag tag;
  };
  V0_Body v0;
  V1_Body v1;
};

/// A byte-string with a maximum size of N,
/// where only the first `len` bytes are considered
/// to contain the actual payload. N is only
/// permitted to be between 0 and 255.
template<uintptr_t N>
struct ByteBuffer {
  uint8_t len;
  uint8_t bytes[N];
};

/// Represents the raw contents of the service payload data
/// under the Nearby Presence service UUID
struct RawAdvertisementPayload {
  ByteBuffer<255> bytes;
};

/// Representation of a transmission power,
/// as used for the Tx Power DE in V0 and V1.
struct TxPower {
  int8_t tx_power;
};

/// The bitfield data of a V0Actions data element
struct V0ActionBits {
  uint32_t bitfield;
};

/// Representation of the Actions DE in V0.
struct V0Actions {
  enum class Tag {
    /// A set of action bits which were present in a plaintext identity advertisement
    Plaintext,
    /// A set of action bits which were present in a encrypted identity advertisement
    Encrypted,
  };

  struct Plaintext_Body {
    V0ActionBits _0;
  };

  struct Encrypted_Body {
    V0ActionBits _0;
  };

  Tag tag;
  union {
    Plaintext_Body plaintext;
    Encrypted_Body encrypted;
  };
};

/// Representation of a V0 data element.
struct V0DataElement {
  enum class Tag {
    TxPower,
    Actions,
  };

  struct TxPower_Body {
    TxPower _0;
  };

  struct Actions_Body {
    V0Actions _0;
  };

  Tag tag;
  union {
    TxPower_Body tx_power;
    Actions_Body actions;
  };
};

/// The result of `V0Payload#get_de`.
struct GetV0DEResult {
  enum class Tag {
    Success,
    Error,
  };

  struct Success_Body {
    V0DataElement _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Information about the identity which matched a
/// decrypted V0 advertisement.
struct DeserializedV0IdentityDetails {
  /// The ID of the credential which
  /// matched the deserialized adv
  int64_t cred_id;
  /// The 14-byte legacy identity token
  uint8_t identity_token[14];
  /// The 2-byte advertisement salt
  uint8_t salt[2];
};

/// The result of attempting to get the identity details
/// for a V0 advertisement via
/// `DeserializedV0Advertisement#get_identity_details`.
struct GetV0IdentityDetailsResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    DeserializedV0IdentityDetails _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Handle to a deserialized V1 section
struct DeserializedV1Section {
  LegibleV1Sections legible_sections_handle;
  uint8_t legible_section_index;
  uint8_t num_des;
  DeserializedV1IdentityKind identity_tag;
};

/// The result of attempting to get a particular V1 section
/// from its' index within the list of legible sections
/// via `DeserializedV1Advertisement::get_section`.
struct GetV1SectionResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    DeserializedV1Section _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Representation of the data-element type tag
/// of a V1 data element.
struct V1DEType {
  uint32_t code;
};

/// FFI-transmissible representation of a generic V1 data-element.
/// This representation is stable, and so you may directly
/// reference this struct's fields if you wish.
struct GenericV1DataElement {
  /// The offset of this generic data-element.
  uint8_t offset;
  /// The DE type code of this generic data-element.
  V1DEType de_type;
  /// The raw data-element byte payload, up to
  /// 127 bytes in length.
  ByteBuffer<127> payload;
};

/// FFI-transmissible representation of a V1 data-element
struct V1DataElement {
  enum class Tag {
    /// A "generic" V1 data-element, for which we have no
    /// particular information about its schema (just
    /// a DE type code and a byte payload.)
    Generic,
  };

  struct Generic_Body {
    GenericV1DataElement _0;
  };

  Tag tag;
  union {
    Generic_Body generic;
  };
};

/// Represents the result of the `DeserializedV1Section#get_de` operation.
struct GetV1DEResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    V1DataElement _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Information about the identity which matched
/// a decrypted V1 section.
struct DeserializedV1IdentityDetails {
  /// The verification mode (MIC/Signature) which
  /// was used to verify the decrypted adv contents.
  V1VerificationMode verification_mode;
  /// The ID of the credential which
  /// matched the deserialized section.
  int64_t cred_id;
  /// The 16-byte metadata key.
  uint8_t identity_token[16];
};

/// The result of attempting to get the identity details
/// for a V1 advertisement section via
/// `DeserializedV1Advertisement#get_identity_details`.
struct GetV1IdentityDetailsResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    DeserializedV1IdentityDetails _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// A FFI safe wrapper of a fixed size array
template<uintptr_t N>
struct FixedSizeArray {
  uint8_t _0[N];
};

/// The result of attempting to get a derived 16-byte salt
/// for a given DE within a section.
struct GetV1DE16ByteSaltResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    FixedSizeArray<16> _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// A `#[repr(C)]` handle to a value of type `V0AdvertisementBuilderInternals`
struct V0AdvertisementBuilder {
  uint64_t handle_id;
};

/// The result of attempting to serialize the contents
/// of a V0 advertisement builder to raw bytes.
struct SerializeV0AdvertisementResult {
  enum class Tag {
    Success,
    InvalidAdvertisementBuilderHandle,
    LdtError,
    UnencryptedError,
  };

  struct Success_Body {
    ByteBuffer<24> _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Cryptographic information about a particular V0 broadcast credential
/// necessary to LDT-encrypt V0 advertisements.
struct V0BroadcastCredential {
  uint8_t key_seed[32];
  uint8_t identity_token[14];
};

/// A handle to a builder for V1 advertisements.
struct V1AdvertisementBuilder {
  uint64_t handle_id;
};

/// A handle to a builder for V1 sections. This is not a unique handle; it is the same handle as
/// the advertisement builder the section builder was originated from.
struct V1SectionBuilder {
  /// The parent advertisement builder for this section
  V1AdvertisementBuilder adv_builder;
  /// This section's index in the parent advertisement
  uint8_t section_index;
};

/// The result of attempting to create a new V1 section builder.
struct CreateV1SectionBuilderResult {
  enum class Tag {
    Success,
    UnclosedActiveSection,
    InvalidAdvertisementBuilderHandle,
    IdentityKindMismatch,
    NoSpaceLeft,
  };

  struct Success_Body {
    V1SectionBuilder _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Cryptographic information about a particular V1 broadcast credential
/// necessary to encrypt V1 MIC-verified and signature-verified sections.
struct V1BroadcastCredential {
  uint8_t key_seed[32];
  uint8_t identity_token[16];
  uint8_t private_key[32];
};

/// The result of attempting to serialize the contents
/// of a V1 advertisement builder to raw bytes.
struct SerializeV1AdvertisementResult {
  enum class Tag {
    Success,
    InvalidBuilderState,
    InvalidAdvertisementBuilderHandle,
  };

  struct Success_Body {
    ByteBuffer<250> _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// The result of attempting to get the derived V1 DE
/// 16-byte salt for the next-added DE to the section
/// builder behind the given handle.
struct NextV1DE16ByteSaltResult {
  enum class Tag {
    Error,
    Success,
  };

  struct Success_Body {
    FixedSizeArray<16> _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// Represents the contents of a V1 DE whose payload
/// is stored in a buffer which may contain up to 127 bytes,
/// which is the maximum for any V1 DE.
///
/// This representation is stable, and so you may directly
/// reference this struct's fields if you wish.
struct V1DE127ByteBuffer {
  /// The DE type code of this generic data-element.
  uint32_t de_type;
  /// The raw data-element byte payload, up to
  /// 127 bytes in length.
  ByteBuffer<127> payload;
};

/// Result type for attempting to construct a
/// Tx Power from a signed byte.
struct BuildTxPowerResult {
  enum class Tag {
    OutOfRange,
    Success,
  };

  struct Success_Body {
    TxPower _0;
  };

  Tag tag;
  union {
    Success_Body success;
  };
};

/// The result of attempting to set a particular action
/// bit on some `V0Actions`.
struct SetV0ActionResult {
  enum class Tag {
    Success,
    Error,
  };

  struct Success_Body {
    V0Actions _0;
  };

  struct Error_Body {
    V0Actions _0;
  };

  Tag tag;
  union {
    Success_Body success;
    Error_Body error;
  };
};

} // namespace internal
} // namespace np_ffi

// clang-format on
