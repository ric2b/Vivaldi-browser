// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `securemessage.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.SecureMessage)
pub struct SecureMessage {
    // message fields
    // @@protoc_insertion_point(field:securemessage.SecureMessage.header_and_body)
    pub header_and_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.SecureMessage.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.SecureMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecureMessage {
    fn default() -> &'a SecureMessage {
        <SecureMessage as ::protobuf::Message>::default_instance()
    }
}

impl SecureMessage {
    pub fn new() -> SecureMessage {
        ::std::default::Default::default()
    }

    // required bytes header_and_body = 1;

    pub fn header_and_body(&self) -> &[u8] {
        match self.header_and_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_header_and_body(&mut self) {
        self.header_and_body = ::std::option::Option::None;
    }

    pub fn has_header_and_body(&self) -> bool {
        self.header_and_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_and_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.header_and_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_and_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.header_and_body.is_none() {
            self.header_and_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.header_and_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_and_body(&mut self) -> ::std::vec::Vec<u8> {
        self.header_and_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SecureMessage {
    const NAME: &'static str = "SecureMessage";

    fn is_initialized(&self) -> bool {
        if self.header_and_body.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.header_and_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_and_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header_and_body.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecureMessage {
        SecureMessage::new()
    }

    fn clear(&mut self) {
        self.header_and_body = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecureMessage {
        static instance: SecureMessage = SecureMessage {
            header_and_body: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.Header)
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:securemessage.Header.signature_scheme)
    pub signature_scheme: ::std::option::Option<::protobuf::EnumOrUnknown<SigScheme>>,
    // @@protoc_insertion_point(field:securemessage.Header.encryption_scheme)
    pub encryption_scheme: ::std::option::Option<::protobuf::EnumOrUnknown<EncScheme>>,
    // @@protoc_insertion_point(field:securemessage.Header.verification_key_id)
    pub verification_key_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.Header.decryption_key_id)
    pub decryption_key_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.Header.iv)
    pub iv: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.Header.public_metadata)
    pub public_metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.Header.associated_data_length)
    pub associated_data_length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:securemessage.Header.nonce)
    pub nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    // required .securemessage.SigScheme signature_scheme = 1;

    pub fn signature_scheme(&self) -> SigScheme {
        match self.signature_scheme {
            Some(e) => e.enum_value_or(SigScheme::HMAC_SHA256),
            None => SigScheme::HMAC_SHA256,
        }
    }

    pub fn clear_signature_scheme(&mut self) {
        self.signature_scheme = ::std::option::Option::None;
    }

    pub fn has_signature_scheme(&self) -> bool {
        self.signature_scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature_scheme(&mut self, v: SigScheme) {
        self.signature_scheme = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .securemessage.EncScheme encryption_scheme = 2;

    pub fn encryption_scheme(&self) -> EncScheme {
        match self.encryption_scheme {
            Some(e) => e.enum_value_or(EncScheme::NONE),
            None => EncScheme::NONE,
        }
    }

    pub fn clear_encryption_scheme(&mut self) {
        self.encryption_scheme = ::std::option::Option::None;
    }

    pub fn has_encryption_scheme(&self) -> bool {
        self.encryption_scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_scheme(&mut self, v: EncScheme) {
        self.encryption_scheme = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes verification_key_id = 3;

    pub fn verification_key_id(&self) -> &[u8] {
        match self.verification_key_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_verification_key_id(&mut self) {
        self.verification_key_id = ::std::option::Option::None;
    }

    pub fn has_verification_key_id(&self) -> bool {
        self.verification_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verification_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.verification_key_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verification_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.verification_key_id.is_none() {
            self.verification_key_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.verification_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_verification_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.verification_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes decryption_key_id = 4;

    pub fn decryption_key_id(&self) -> &[u8] {
        match self.decryption_key_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_decryption_key_id(&mut self) {
        self.decryption_key_id = ::std::option::Option::None;
    }

    pub fn has_decryption_key_id(&self) -> bool {
        self.decryption_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decryption_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.decryption_key_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decryption_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.decryption_key_id.is_none() {
            self.decryption_key_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.decryption_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_decryption_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.decryption_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes iv = 5;

    pub fn iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_iv(&mut self) {
        self.iv = ::std::option::Option::None;
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes public_metadata = 6;

    pub fn public_metadata(&self) -> &[u8] {
        match self.public_metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_metadata(&mut self) {
        self.public_metadata = ::std::option::Option::None;
    }

    pub fn has_public_metadata(&self) -> bool {
        self.public_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_metadata.is_none() {
            self.public_metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.public_metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 associated_data_length = 7;

    pub fn associated_data_length(&self) -> u32 {
        self.associated_data_length.unwrap_or(0u32)
    }

    pub fn clear_associated_data_length(&mut self) {
        self.associated_data_length = ::std::option::Option::None;
    }

    pub fn has_associated_data_length(&self) -> bool {
        self.associated_data_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_data_length(&mut self, v: u32) {
        self.associated_data_length = ::std::option::Option::Some(v);
    }

    // optional bytes nonce = 8;

    pub fn nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        if self.signature_scheme.is_none() {
            return false;
        }
        if self.encryption_scheme.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.signature_scheme = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.encryption_scheme = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.verification_key_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.decryption_key_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.iv = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.public_metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.associated_data_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature_scheme {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.encryption_scheme {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.verification_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.decryption_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.public_metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.associated_data_length {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature_scheme {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.encryption_scheme {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.verification_key_id.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.decryption_key_id.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.iv.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.public_metadata.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.associated_data_length {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.nonce.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.signature_scheme = ::std::option::Option::None;
        self.encryption_scheme = ::std::option::Option::None;
        self.verification_key_id = ::std::option::Option::None;
        self.decryption_key_id = ::std::option::Option::None;
        self.iv = ::std::option::Option::None;
        self.public_metadata = ::std::option::Option::None;
        self.associated_data_length = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            signature_scheme: ::std::option::Option::None,
            encryption_scheme: ::std::option::Option::None,
            verification_key_id: ::std::option::Option::None,
            decryption_key_id: ::std::option::Option::None,
            iv: ::std::option::Option::None,
            public_metadata: ::std::option::Option::None,
            associated_data_length: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.HeaderAndBody)
pub struct HeaderAndBody {
    // message fields
    // @@protoc_insertion_point(field:securemessage.HeaderAndBody.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:securemessage.HeaderAndBody.body)
    pub body: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.HeaderAndBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderAndBody {
    fn default() -> &'a HeaderAndBody {
        <HeaderAndBody as ::protobuf::Message>::default_instance()
    }
}

impl HeaderAndBody {
    pub fn new() -> HeaderAndBody {
        ::std::default::Default::default()
    }

    // required bytes body = 2;

    pub fn body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HeaderAndBody {
    const NAME: &'static str = "HeaderAndBody";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderAndBody {
        HeaderAndBody::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderAndBody {
        static instance: HeaderAndBody = HeaderAndBody {
            header: ::protobuf::MessageField::none(),
            body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.EcP256PublicKey)
pub struct EcP256PublicKey {
    // message fields
    // @@protoc_insertion_point(field:securemessage.EcP256PublicKey.x)
    pub x: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.EcP256PublicKey.y)
    pub y: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.EcP256PublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EcP256PublicKey {
    fn default() -> &'a EcP256PublicKey {
        <EcP256PublicKey as ::protobuf::Message>::default_instance()
    }
}

impl EcP256PublicKey {
    pub fn new() -> EcP256PublicKey {
        ::std::default::Default::default()
    }

    // required bytes x = 1;

    pub fn x(&self) -> &[u8] {
        match self.x.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: ::std::vec::Vec<u8>) {
        self.x = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.x.is_none() {
            self.x = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> ::std::vec::Vec<u8> {
        self.x.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes y = 2;

    pub fn y(&self) -> &[u8] {
        match self.y.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: ::std::vec::Vec<u8>) {
        self.y = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.y.is_none() {
            self.y = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> ::std::vec::Vec<u8> {
        self.y.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EcP256PublicKey {
    const NAME: &'static str = "EcP256PublicKey";

    fn is_initialized(&self) -> bool {
        if self.x.is_none() {
            return false;
        }
        if self.y.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.x = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.y = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.y.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.y.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EcP256PublicKey {
        EcP256PublicKey::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EcP256PublicKey {
        static instance: EcP256PublicKey = EcP256PublicKey {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.SimpleRsaPublicKey)
pub struct SimpleRsaPublicKey {
    // message fields
    // @@protoc_insertion_point(field:securemessage.SimpleRsaPublicKey.n)
    pub n: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securemessage.SimpleRsaPublicKey.e)
    pub e: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.SimpleRsaPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SimpleRsaPublicKey {
    fn default() -> &'a SimpleRsaPublicKey {
        <SimpleRsaPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl SimpleRsaPublicKey {
    pub fn new() -> SimpleRsaPublicKey {
        ::std::default::Default::default()
    }

    // required bytes n = 1;

    pub fn n(&self) -> &[u8] {
        match self.n.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_n(&mut self) {
        self.n = ::std::option::Option::None;
    }

    pub fn has_n(&self) -> bool {
        self.n.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n(&mut self, v: ::std::vec::Vec<u8>) {
        self.n = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.n.is_none() {
            self.n = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.n.as_mut().unwrap()
    }

    // Take field
    pub fn take_n(&mut self) -> ::std::vec::Vec<u8> {
        self.n.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 e = 2;

    pub fn e(&self) -> i32 {
        self.e.unwrap_or(65537i32)
    }

    pub fn clear_e(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_e(&self) -> bool {
        self.e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e(&mut self, v: i32) {
        self.e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SimpleRsaPublicKey {
    const NAME: &'static str = "SimpleRsaPublicKey";

    fn is_initialized(&self) -> bool {
        if self.n.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.n = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.e = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.n.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.e {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.n.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.e {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SimpleRsaPublicKey {
        SimpleRsaPublicKey::new()
    }

    fn clear(&mut self) {
        self.n = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SimpleRsaPublicKey {
        static instance: SimpleRsaPublicKey = SimpleRsaPublicKey {
            n: ::std::option::Option::None,
            e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.DhPublicKey)
pub struct DhPublicKey {
    // message fields
    // @@protoc_insertion_point(field:securemessage.DhPublicKey.y)
    pub y: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.DhPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DhPublicKey {
    fn default() -> &'a DhPublicKey {
        <DhPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl DhPublicKey {
    pub fn new() -> DhPublicKey {
        ::std::default::Default::default()
    }

    // required bytes y = 1;

    pub fn y(&self) -> &[u8] {
        match self.y.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: ::std::vec::Vec<u8>) {
        self.y = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.y.is_none() {
            self.y = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> ::std::vec::Vec<u8> {
        self.y.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DhPublicKey {
    const NAME: &'static str = "DhPublicKey";

    fn is_initialized(&self) -> bool {
        if self.y.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.y = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.y.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.y.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DhPublicKey {
        DhPublicKey::new()
    }

    fn clear(&mut self) {
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DhPublicKey {
        static instance: DhPublicKey = DhPublicKey {
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securemessage.GenericPublicKey)
pub struct GenericPublicKey {
    // message fields
    // @@protoc_insertion_point(field:securemessage.GenericPublicKey.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<PublicKeyType>>,
    // @@protoc_insertion_point(field:securemessage.GenericPublicKey.ec_p256_public_key)
    pub ec_p256_public_key: ::protobuf::MessageField<EcP256PublicKey>,
    // @@protoc_insertion_point(field:securemessage.GenericPublicKey.rsa2048_public_key)
    pub rsa2048_public_key: ::protobuf::MessageField<SimpleRsaPublicKey>,
    // @@protoc_insertion_point(field:securemessage.GenericPublicKey.dh2048_public_key)
    pub dh2048_public_key: ::protobuf::MessageField<DhPublicKey>,
    // special fields
    // @@protoc_insertion_point(special_field:securemessage.GenericPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericPublicKey {
    fn default() -> &'a GenericPublicKey {
        <GenericPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl GenericPublicKey {
    pub fn new() -> GenericPublicKey {
        ::std::default::Default::default()
    }

    // required .securemessage.PublicKeyType type = 1;

    pub fn type_(&self) -> PublicKeyType {
        match self.type_ {
            Some(e) => e.enum_value_or(PublicKeyType::EC_P256),
            None => PublicKeyType::EC_P256,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PublicKeyType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for GenericPublicKey {
    const NAME: &'static str = "GenericPublicKey";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.ec_p256_public_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rsa2048_public_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dh2048_public_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ec_p256_public_key)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsa2048_public_key)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dh2048_public_key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ec_p256_public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rsa2048_public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dh2048_public_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ec_p256_public_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.rsa2048_public_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.dh2048_public_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericPublicKey {
        GenericPublicKey::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.ec_p256_public_key.clear();
        self.rsa2048_public_key.clear();
        self.dh2048_public_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericPublicKey {
        static instance: GenericPublicKey = GenericPublicKey {
            type_: ::std::option::Option::None,
            ec_p256_public_key: ::protobuf::MessageField::none(),
            rsa2048_public_key: ::protobuf::MessageField::none(),
            dh2048_public_key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securemessage.SigScheme)
pub enum SigScheme {
    // @@protoc_insertion_point(enum_value:securemessage.SigScheme.HMAC_SHA256)
    HMAC_SHA256 = 1,
    // @@protoc_insertion_point(enum_value:securemessage.SigScheme.ECDSA_P256_SHA256)
    ECDSA_P256_SHA256 = 2,
    // @@protoc_insertion_point(enum_value:securemessage.SigScheme.RSA2048_SHA256)
    RSA2048_SHA256 = 3,
    // @@protoc_insertion_point(enum_value:securemessage.SigScheme.AEAD)
    AEAD = 4,
}

impl ::protobuf::Enum for SigScheme {
    const NAME: &'static str = "SigScheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SigScheme> {
        match value {
            1 => ::std::option::Option::Some(SigScheme::HMAC_SHA256),
            2 => ::std::option::Option::Some(SigScheme::ECDSA_P256_SHA256),
            3 => ::std::option::Option::Some(SigScheme::RSA2048_SHA256),
            4 => ::std::option::Option::Some(SigScheme::AEAD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SigScheme] = &[
        SigScheme::HMAC_SHA256,
        SigScheme::ECDSA_P256_SHA256,
        SigScheme::RSA2048_SHA256,
        SigScheme::AEAD,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SigScheme {
    fn default() -> Self {
        SigScheme::HMAC_SHA256
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securemessage.EncScheme)
pub enum EncScheme {
    // @@protoc_insertion_point(enum_value:securemessage.EncScheme.NONE)
    NONE = 1,
    // @@protoc_insertion_point(enum_value:securemessage.EncScheme.AES_256_CBC)
    AES_256_CBC = 2,
    // @@protoc_insertion_point(enum_value:securemessage.EncScheme.AES_256_GCM_SIV)
    AES_256_GCM_SIV = 3,
}

impl ::protobuf::Enum for EncScheme {
    const NAME: &'static str = "EncScheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncScheme> {
        match value {
            1 => ::std::option::Option::Some(EncScheme::NONE),
            2 => ::std::option::Option::Some(EncScheme::AES_256_CBC),
            3 => ::std::option::Option::Some(EncScheme::AES_256_GCM_SIV),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EncScheme] = &[
        EncScheme::NONE,
        EncScheme::AES_256_CBC,
        EncScheme::AES_256_GCM_SIV,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EncScheme {
    fn default() -> Self {
        EncScheme::NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securemessage.PublicKeyType)
pub enum PublicKeyType {
    // @@protoc_insertion_point(enum_value:securemessage.PublicKeyType.EC_P256)
    EC_P256 = 1,
    // @@protoc_insertion_point(enum_value:securemessage.PublicKeyType.RSA2048)
    RSA2048 = 2,
    // @@protoc_insertion_point(enum_value:securemessage.PublicKeyType.DH2048_MODP)
    DH2048_MODP = 3,
}

impl ::protobuf::Enum for PublicKeyType {
    const NAME: &'static str = "PublicKeyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PublicKeyType> {
        match value {
            1 => ::std::option::Option::Some(PublicKeyType::EC_P256),
            2 => ::std::option::Option::Some(PublicKeyType::RSA2048),
            3 => ::std::option::Option::Some(PublicKeyType::DH2048_MODP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PublicKeyType] = &[
        PublicKeyType::EC_P256,
        PublicKeyType::RSA2048,
        PublicKeyType::DH2048_MODP,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PublicKeyType {
    fn default() -> Self {
        PublicKeyType::EC_P256
    }
}

