// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ukey.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Ukey2Message)
pub struct Ukey2Message {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Ukey2Message.message_type)
    pub message_type: ::std::option::Option<::protobuf::EnumOrUnknown<ukey2message::Type>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2Message.message_data)
    pub message_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Ukey2Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ukey2Message {
    fn default() -> &'a Ukey2Message {
        <Ukey2Message as ::protobuf::Message>::default_instance()
    }
}

impl Ukey2Message {
    pub fn new() -> Ukey2Message {
        ::std::default::Default::default()
    }

    // optional .securegcm.Ukey2Message.Type message_type = 1;

    pub fn message_type(&self) -> ukey2message::Type {
        match self.message_type {
            Some(e) => e.enum_value_or(ukey2message::Type::UNKNOWN_DO_NOT_USE),
            None => ukey2message::Type::UNKNOWN_DO_NOT_USE,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: ukey2message::Type) {
        self.message_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes message_data = 2;

    pub fn message_data(&self) -> &[u8] {
        match self.message_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_data(&mut self) {
        self.message_data = ::std::option::Option::None;
    }

    pub fn has_message_data(&self) -> bool {
        self.message_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_data.is_none() {
            self.message_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_data(&mut self) -> ::std::vec::Vec<u8> {
        self.message_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Ukey2Message {
    const NAME: &'static str = "Ukey2Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.message_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.message_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ukey2Message {
        Ukey2Message::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.message_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ukey2Message {
        static instance: Ukey2Message = Ukey2Message {
            message_type: ::std::option::Option::None,
            message_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Ukey2Message`
pub mod ukey2message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:securegcm.Ukey2Message.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Message.Type.UNKNOWN_DO_NOT_USE)
        UNKNOWN_DO_NOT_USE = 0,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Message.Type.ALERT)
        ALERT = 1,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Message.Type.CLIENT_INIT)
        CLIENT_INIT = 2,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Message.Type.SERVER_INIT)
        SERVER_INIT = 3,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Message.Type.CLIENT_FINISH)
        CLIENT_FINISH = 4,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::UNKNOWN_DO_NOT_USE),
                1 => ::std::option::Option::Some(Type::ALERT),
                2 => ::std::option::Option::Some(Type::CLIENT_INIT),
                3 => ::std::option::Option::Some(Type::SERVER_INIT),
                4 => ::std::option::Option::Some(Type::CLIENT_FINISH),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::UNKNOWN_DO_NOT_USE,
            Type::ALERT,
            Type::CLIENT_INIT,
            Type::SERVER_INIT,
            Type::CLIENT_FINISH,
        ];
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::UNKNOWN_DO_NOT_USE
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Ukey2Alert)
pub struct Ukey2Alert {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Ukey2Alert.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ukey2alert::AlertType>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2Alert.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Ukey2Alert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ukey2Alert {
    fn default() -> &'a Ukey2Alert {
        <Ukey2Alert as ::protobuf::Message>::default_instance()
    }
}

impl Ukey2Alert {
    pub fn new() -> Ukey2Alert {
        ::std::default::Default::default()
    }

    // optional .securegcm.Ukey2Alert.AlertType type = 1;

    pub fn type_(&self) -> ukey2alert::AlertType {
        match self.type_ {
            Some(e) => e.enum_value_or(ukey2alert::AlertType::BAD_MESSAGE),
            None => ukey2alert::AlertType::BAD_MESSAGE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ukey2alert::AlertType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_message = 2;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ukey2Alert {
    const NAME: &'static str = "Ukey2Alert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ukey2Alert {
        Ukey2Alert::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ukey2Alert {
        static instance: Ukey2Alert = Ukey2Alert {
            type_: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Ukey2Alert`
pub mod ukey2alert {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:securegcm.Ukey2Alert.AlertType)
    pub enum AlertType {
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_MESSAGE)
        BAD_MESSAGE = 1,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_MESSAGE_TYPE)
        BAD_MESSAGE_TYPE = 2,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.INCORRECT_MESSAGE)
        INCORRECT_MESSAGE = 3,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_MESSAGE_DATA)
        BAD_MESSAGE_DATA = 4,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_VERSION)
        BAD_VERSION = 100,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_RANDOM)
        BAD_RANDOM = 101,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_HANDSHAKE_CIPHER)
        BAD_HANDSHAKE_CIPHER = 102,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_NEXT_PROTOCOL)
        BAD_NEXT_PROTOCOL = 103,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.BAD_PUBLIC_KEY)
        BAD_PUBLIC_KEY = 104,
        // @@protoc_insertion_point(enum_value:securegcm.Ukey2Alert.AlertType.INTERNAL_ERROR)
        INTERNAL_ERROR = 200,
    }

    impl ::protobuf::Enum for AlertType {
        const NAME: &'static str = "AlertType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AlertType> {
            match value {
                1 => ::std::option::Option::Some(AlertType::BAD_MESSAGE),
                2 => ::std::option::Option::Some(AlertType::BAD_MESSAGE_TYPE),
                3 => ::std::option::Option::Some(AlertType::INCORRECT_MESSAGE),
                4 => ::std::option::Option::Some(AlertType::BAD_MESSAGE_DATA),
                100 => ::std::option::Option::Some(AlertType::BAD_VERSION),
                101 => ::std::option::Option::Some(AlertType::BAD_RANDOM),
                102 => ::std::option::Option::Some(AlertType::BAD_HANDSHAKE_CIPHER),
                103 => ::std::option::Option::Some(AlertType::BAD_NEXT_PROTOCOL),
                104 => ::std::option::Option::Some(AlertType::BAD_PUBLIC_KEY),
                200 => ::std::option::Option::Some(AlertType::INTERNAL_ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AlertType] = &[
            AlertType::BAD_MESSAGE,
            AlertType::BAD_MESSAGE_TYPE,
            AlertType::INCORRECT_MESSAGE,
            AlertType::BAD_MESSAGE_DATA,
            AlertType::BAD_VERSION,
            AlertType::BAD_RANDOM,
            AlertType::BAD_HANDSHAKE_CIPHER,
            AlertType::BAD_NEXT_PROTOCOL,
            AlertType::BAD_PUBLIC_KEY,
            AlertType::INTERNAL_ERROR,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for AlertType {
        fn default() -> Self {
            AlertType::BAD_MESSAGE
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Ukey2ClientInit)
pub struct Ukey2ClientInit {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.random)
    pub random: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.cipher_commitments)
    pub cipher_commitments: ::std::vec::Vec<ukey2client_init::CipherCommitment>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.next_protocol)
    pub next_protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.other_next_protocols)
    pub other_next_protocols: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Ukey2ClientInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ukey2ClientInit {
    fn default() -> &'a Ukey2ClientInit {
        <Ukey2ClientInit as ::protobuf::Message>::default_instance()
    }
}

impl Ukey2ClientInit {
    pub fn new() -> Ukey2ClientInit {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes random = 2;

    pub fn random(&self) -> &[u8] {
        match self.random.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_random(&mut self) {
        self.random = ::std::option::Option::None;
    }

    pub fn has_random(&self) -> bool {
        self.random.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random(&mut self, v: ::std::vec::Vec<u8>) {
        self.random = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.random.is_none() {
            self.random = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.random.as_mut().unwrap()
    }

    // Take field
    pub fn take_random(&mut self) -> ::std::vec::Vec<u8> {
        self.random.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string next_protocol = 4;

    pub fn next_protocol(&self) -> &str {
        match self.next_protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_next_protocol(&mut self) {
        self.next_protocol = ::std::option::Option::None;
    }

    pub fn has_next_protocol(&self) -> bool {
        self.next_protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_protocol(&mut self, v: ::std::string::String) {
        self.next_protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_protocol(&mut self) -> &mut ::std::string::String {
        if self.next_protocol.is_none() {
            self.next_protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.next_protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_protocol(&mut self) -> ::std::string::String {
        self.next_protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ukey2ClientInit {
    const NAME: &'static str = "Ukey2ClientInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.random = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.cipher_commitments.push(is.read_message()?);
                },
                34 => {
                    self.next_protocol = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.other_next_protocols.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.random.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.cipher_commitments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.other_next_protocols {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.random.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.cipher_commitments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.next_protocol.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.other_next_protocols {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ukey2ClientInit {
        Ukey2ClientInit::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.random = ::std::option::Option::None;
        self.cipher_commitments.clear();
        self.next_protocol = ::std::option::Option::None;
        self.other_next_protocols.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ukey2ClientInit {
        static instance: Ukey2ClientInit = Ukey2ClientInit {
            version: ::std::option::Option::None,
            random: ::std::option::Option::None,
            cipher_commitments: ::std::vec::Vec::new(),
            next_protocol: ::std::option::Option::None,
            other_next_protocols: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Ukey2ClientInit`
pub mod ukey2client_init {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:securegcm.Ukey2ClientInit.CipherCommitment)
    pub struct CipherCommitment {
        // message fields
        // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.CipherCommitment.handshake_cipher)
        pub handshake_cipher: ::std::option::Option<::protobuf::EnumOrUnknown<super::Ukey2HandshakeCipher>>,
        // @@protoc_insertion_point(field:securegcm.Ukey2ClientInit.CipherCommitment.commitment)
        pub commitment: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:securegcm.Ukey2ClientInit.CipherCommitment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CipherCommitment {
        fn default() -> &'a CipherCommitment {
            <CipherCommitment as ::protobuf::Message>::default_instance()
        }
    }

    impl CipherCommitment {
        pub fn new() -> CipherCommitment {
            ::std::default::Default::default()
        }

        // optional .securegcm.Ukey2HandshakeCipher handshake_cipher = 1;

        pub fn handshake_cipher(&self) -> super::Ukey2HandshakeCipher {
            match self.handshake_cipher {
                Some(e) => e.enum_value_or(super::Ukey2HandshakeCipher::RESERVED),
                None => super::Ukey2HandshakeCipher::RESERVED,
            }
        }

        pub fn clear_handshake_cipher(&mut self) {
            self.handshake_cipher = ::std::option::Option::None;
        }

        pub fn has_handshake_cipher(&self) -> bool {
            self.handshake_cipher.is_some()
        }

        // Param is passed by value, moved
        pub fn set_handshake_cipher(&mut self, v: super::Ukey2HandshakeCipher) {
            self.handshake_cipher = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes commitment = 2;

        pub fn commitment(&self) -> &[u8] {
            match self.commitment.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_commitment(&mut self) {
            self.commitment = ::std::option::Option::None;
        }

        pub fn has_commitment(&self) -> bool {
            self.commitment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_commitment(&mut self, v: ::std::vec::Vec<u8>) {
            self.commitment = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.commitment.is_none() {
                self.commitment = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.commitment.as_mut().unwrap()
        }

        // Take field
        pub fn take_commitment(&mut self) -> ::std::vec::Vec<u8> {
            self.commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for CipherCommitment {
        const NAME: &'static str = "CipherCommitment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.handshake_cipher = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.commitment = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.handshake_cipher {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.commitment.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.handshake_cipher {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.commitment.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CipherCommitment {
            CipherCommitment::new()
        }

        fn clear(&mut self) {
            self.handshake_cipher = ::std::option::Option::None;
            self.commitment = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CipherCommitment {
            static instance: CipherCommitment = CipherCommitment {
                handshake_cipher: ::std::option::Option::None,
                commitment: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Ukey2ServerInit)
pub struct Ukey2ServerInit {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Ukey2ServerInit.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ServerInit.random)
    pub random: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ServerInit.handshake_cipher)
    pub handshake_cipher: ::std::option::Option<::protobuf::EnumOrUnknown<Ukey2HandshakeCipher>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ServerInit.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.Ukey2ServerInit.selected_next_protocol)
    pub selected_next_protocol: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Ukey2ServerInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ukey2ServerInit {
    fn default() -> &'a Ukey2ServerInit {
        <Ukey2ServerInit as ::protobuf::Message>::default_instance()
    }
}

impl Ukey2ServerInit {
    pub fn new() -> Ukey2ServerInit {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes random = 2;

    pub fn random(&self) -> &[u8] {
        match self.random.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_random(&mut self) {
        self.random = ::std::option::Option::None;
    }

    pub fn has_random(&self) -> bool {
        self.random.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random(&mut self, v: ::std::vec::Vec<u8>) {
        self.random = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.random.is_none() {
            self.random = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.random.as_mut().unwrap()
    }

    // Take field
    pub fn take_random(&mut self) -> ::std::vec::Vec<u8> {
        self.random.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .securegcm.Ukey2HandshakeCipher handshake_cipher = 3;

    pub fn handshake_cipher(&self) -> Ukey2HandshakeCipher {
        match self.handshake_cipher {
            Some(e) => e.enum_value_or(Ukey2HandshakeCipher::RESERVED),
            None => Ukey2HandshakeCipher::RESERVED,
        }
    }

    pub fn clear_handshake_cipher(&mut self) {
        self.handshake_cipher = ::std::option::Option::None;
    }

    pub fn has_handshake_cipher(&self) -> bool {
        self.handshake_cipher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handshake_cipher(&mut self, v: Ukey2HandshakeCipher) {
        self.handshake_cipher = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes public_key = 4;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string selected_next_protocol = 5;

    pub fn selected_next_protocol(&self) -> &str {
        match self.selected_next_protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selected_next_protocol(&mut self) {
        self.selected_next_protocol = ::std::option::Option::None;
    }

    pub fn has_selected_next_protocol(&self) -> bool {
        self.selected_next_protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_next_protocol(&mut self, v: ::std::string::String) {
        self.selected_next_protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_next_protocol(&mut self) -> &mut ::std::string::String {
        if self.selected_next_protocol.is_none() {
            self.selected_next_protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selected_next_protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_next_protocol(&mut self) -> ::std::string::String {
        self.selected_next_protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Ukey2ServerInit {
    const NAME: &'static str = "Ukey2ServerInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.random = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.handshake_cipher = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.selected_next_protocol = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.random.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.handshake_cipher {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.selected_next_protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.random.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.handshake_cipher {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.selected_next_protocol.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ukey2ServerInit {
        Ukey2ServerInit::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.random = ::std::option::Option::None;
        self.handshake_cipher = ::std::option::Option::None;
        self.public_key = ::std::option::Option::None;
        self.selected_next_protocol = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ukey2ServerInit {
        static instance: Ukey2ServerInit = Ukey2ServerInit {
            version: ::std::option::Option::None,
            random: ::std::option::Option::None,
            handshake_cipher: ::std::option::Option::None,
            public_key: ::std::option::Option::None,
            selected_next_protocol: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Ukey2ClientFinished)
pub struct Ukey2ClientFinished {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Ukey2ClientFinished.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Ukey2ClientFinished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ukey2ClientFinished {
    fn default() -> &'a Ukey2ClientFinished {
        <Ukey2ClientFinished as ::protobuf::Message>::default_instance()
    }
}

impl Ukey2ClientFinished {
    pub fn new() -> Ukey2ClientFinished {
        ::std::default::Default::default()
    }

    // optional bytes public_key = 1;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Ukey2ClientFinished {
    const NAME: &'static str = "Ukey2ClientFinished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ukey2ClientFinished {
        Ukey2ClientFinished::new()
    }

    fn clear(&mut self) {
        self.public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ukey2ClientFinished {
        static instance: Ukey2ClientFinished = Ukey2ClientFinished {
            public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.Ukey2HandshakeCipher)
pub enum Ukey2HandshakeCipher {
    // @@protoc_insertion_point(enum_value:securegcm.Ukey2HandshakeCipher.RESERVED)
    RESERVED = 0,
    // @@protoc_insertion_point(enum_value:securegcm.Ukey2HandshakeCipher.P256_SHA512)
    P256_SHA512 = 100,
    // @@protoc_insertion_point(enum_value:securegcm.Ukey2HandshakeCipher.CURVE25519_SHA512)
    CURVE25519_SHA512 = 200,
}

impl ::protobuf::Enum for Ukey2HandshakeCipher {
    const NAME: &'static str = "Ukey2HandshakeCipher";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Ukey2HandshakeCipher> {
        match value {
            0 => ::std::option::Option::Some(Ukey2HandshakeCipher::RESERVED),
            100 => ::std::option::Option::Some(Ukey2HandshakeCipher::P256_SHA512),
            200 => ::std::option::Option::Some(Ukey2HandshakeCipher::CURVE25519_SHA512),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Ukey2HandshakeCipher] = &[
        Ukey2HandshakeCipher::RESERVED,
        Ukey2HandshakeCipher::P256_SHA512,
        Ukey2HandshakeCipher::CURVE25519_SHA512,
    ];
}

impl ::std::default::Default for Ukey2HandshakeCipher {
    fn default() -> Self {
        Ukey2HandshakeCipher::RESERVED
    }
}

