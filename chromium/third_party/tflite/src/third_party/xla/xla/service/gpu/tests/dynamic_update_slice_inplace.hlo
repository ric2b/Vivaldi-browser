// This test explicitly disables MLIR emitters. The unit tests in
// in_place_dynamic_update_slice_mlir_test cover what is tested here - when
// the flag is removed, this test file can be deleted.
// RUN: hlo-opt %s --xla_gpu_mlir_emitter_level=0 --platform=gpu --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb --split-input-file | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_1:.*]] = icmp sge i32 0, %[[VAL_0]]
// CHECK:         %[[VAL_2:.*]] = select i1 %[[VAL_1]], i32 0, i32 %[[VAL_0]]
// CHECK:         %[[VAL_3:.*]] = icmp sle i32 49, %[[VAL_2]]
// CHECK:         %[[VAL_4:.*]] = select i1 %[[VAL_3]], i32 49, i32 %[[VAL_2]]
// CHECK:         %[[VAL_5:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_6:.*]] = icmp sge i32 0, %[[VAL_5]]
// CHECK:         %[[VAL_7:.*]] = select i1 %[[VAL_6]], i32 0, i32 %[[VAL_5]]
// CHECK:         %[[VAL_8:.*]] = icmp sle i32 0, %[[VAL_7]]
// CHECK:         %[[VAL_9:.*]] = select i1 %[[VAL_8]], i32 0, i32 %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_11:.*]] = icmp sge i32 0, %[[VAL_10]]
// CHECK:         %[[VAL_12:.*]] = select i1 %[[VAL_11]], i32 0, i32 %[[VAL_10]]
// CHECK:         %[[VAL_13:.*]] = icmp sle i32 0, %[[VAL_12]]
// CHECK:         %[[VAL_14:.*]] = select i1 %[[VAL_13]], i32 0, i32 %[[VAL_12]]
// CHECK-PTX:     %[[VAL_15:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_15:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK:         %[[VAL_16:.*]] = zext i32 %[[VAL_15]] to i64
// CHECK-PTX:     %[[VAL_17:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_17:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_18:.*]] = zext i32 %[[VAL_17]] to i64
// CHECK-PTX:     %[[VAL_19:.*]] = mul nuw nsw i64 %[[VAL_16]], 128
// CHECK-GCN:     %[[VAL_19:.*]] = mul nuw nsw i64 %[[VAL_16]], 256
// CHECK:         %[[VAL_20:.*]] = add nuw nsw i64 %[[VAL_19]], %[[VAL_18]]
// CHECK:         %[[VAL_21:.*]] = icmp ult i64 %[[VAL_20]], 98304
// CHECK:         call void @llvm.assume(i1 %[[VAL_21]])
// CHECK:         %[[VAL_22:.*]] = add nuw nsw i64 %[[VAL_20]], 0
// CHECK:         %[[VAL_23:.*]] = udiv i64 %[[VAL_22]], 1
// CHECK:         %[[VAL_24:.*]] = urem i64 %[[VAL_23]], 1024
// CHECK:         %[[VAL_25:.*]] = udiv i64 %[[VAL_22]], 1024
// CHECK:         %[[VAL_26:.*]] = urem i64 %[[VAL_25]], 96
// CHECK:         %[[VAL_27:.*]] = udiv i64 %[[VAL_22]], 98304
// CHECK:         %[[VAL_28:.*]] = icmp ult i64 %[[VAL_20]], 98304
// CHECK:         br i1 %[[VAL_28]], label %[[VAL_29:.*]], label %[[VAL_30:.*]]
// CHECK:       dynamic-update-slice.in_bounds-after:             ; preds = %[[VAL_29]], %[[VAL_31:.*]]
// CHECK:         ret void
// CHECK:       dynamic-update-slice.in_bounds-true:              ; preds = %[[VAL_31]]
// CHECK:         %[[VAL_32:.*]] = sext i32 %[[VAL_4]] to i64
// CHECK:         %[[VAL_33:.*]] = add i64 %[[VAL_32]], %[[VAL_27]]
// CHECK:         %[[VAL_34:.*]] = sext i32 %[[VAL_9]] to i64
// CHECK:         %[[VAL_35:.*]] = add i64 %[[VAL_34]], %[[VAL_26]]
// CHECK:         %[[VAL_36:.*]] = sext i32 %[[VAL_14]] to i64
// CHECK:         %[[VAL_37:.*]] = add i64 %[[VAL_36]], %[[VAL_24]]
// CHECK:         %[[VAL_38:.*]] = getelementptr half, ptr %[[VAL_39:.*]], i64 %[[VAL_20]]
// CHECK:         %[[VAL_40:.*]] = getelementptr inbounds half, ptr %[[VAL_38]], i64 0
// CHECK:         %[[VAL_41:.*]] = load half, ptr %[[VAL_40]], align 2, !invariant.load
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds [50 x [96 x [1024 x half]]], ptr %[[VAL_43:.*]], i64 0, i64 %[[VAL_33]], i64 %[[VAL_35]], i64 %[[VAL_37]]
// CHECK:         store half %[[VAL_41]], ptr %[[VAL_42]], align 2
// CHECK:         br label %[[VAL_30]]

HloModule TestModule, is_scheduled=true

fusion.1 {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  c.0 = s32[] constant(0)
  ROOT %dynamic-update-slice = f16[50,96,1024]{2,1,0} dynamic-update-slice(p.0, p.1, c.0, c.0, c.0)
}

ENTRY entry {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  ROOT f1 = f16[50,96,1024] fusion(p.0, p.1), kind=kLoop, calls=fusion.1
}

// -----

// CHECK-LABEL: @fusion
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]]
// CHECK:         call void @llvm.assume
// CHECK:         %[[COND:.*]] = icmp ult i32 %[[LINEAR_INDEX:.*]], 6
// CHECK:         br i1 %[[COND]], label %[[FUSION:.*]].in_bounds-true, label %[[FUSION]].in_bounds-after
// CHECK:       [[FUSION]].in_bounds-after:
// CHECK:         ret void
// CHECK:       [[FUSION]].in_bounds-true:
// CHECK:         br i1 %{{.*}}, label %[[SLICE:.*]]-true, label %[[SLICE]]-false
// CHECK:       [[SLICE]]-after:
// CHECK-PTX:     %[[VAL_85:.*]] = load i32, ptr %[[RET_VALUE_ADDR:.*]], align 4
// CHECK-GCN:     %[[VAL_85:.*]] = load i32, ptr addrspace(5) %[[RET_VALUE_ADDR:.*]], align 4
// CHECK:         %[[VAL_86:.*]] = getelementptr i32, ptr %[[ARG2]], i32 %[[LINEAR_INDEX]]
// CHECK:         %[[VAL_88:.*]] = getelementptr inbounds i32, ptr %[[VAL_86]], i32 0
// CHECK:         store i32 %[[VAL_85]], ptr %[[VAL_88]], align 4
// CHECK:         br label %[[FUSION]].in_bounds-after
// CHECK:       [[SLICE]]-true:
// CHECK:         %[[VAL_108:.*]] = getelementptr inbounds [6 x i32], ptr %[[ARG0]], i32 0, i32 %[[VAL_106:.*]]
// CHECK:         %[[VAL_110:.*]] = load i32, ptr %[[VAL_108]], align 4, !invariant.load
// CHECK:         %[[VAL_111:.*]] = load i32, ptr @1, align 4
// CHECK:         %[[VAL_112:.*]] = add i32 %[[VAL_110]], %[[VAL_111]]
// CHECK-PTX:     store i32 %[[VAL_112]], ptr %[[RET_VALUE_ADDR]], align 4
// CHECK-GCN:     store i32 %[[VAL_112]], ptr addrspace(5) %[[RET_VALUE_ADDR]], align 4
// CHECK:         br label %[[SLICE]]-after
// CHECK:       [[SLICE]]-false:
// CHECK:         %[[VAL_118:.*]] = getelementptr i32, ptr %[[ARG0]], i32 %[[LINEAR_INDEX]]
// CHECK:         %[[VAL_119:.*]] = getelementptr inbounds i32, ptr %[[VAL_118]], i32 0
// CHECK:         %[[VAL_120:.*]] = load i32, ptr %[[VAL_119]], align 4, !invariant.load
// CHECK-PTX:     store i32 %[[VAL_120]], ptr %[[RET_VALUE_ADDR]], align 4
// CHECK-GCN:     store i32 %[[VAL_120]], ptr addrspace(5) %[[RET_VALUE_ADDR]], align 4
// CHECK:         br label %[[SLICE]]-after

HloModule fusion, is_scheduled=true

fused_computation {
  param_0.1 = s32[6]{0} parameter(0)
  bitcast = s32[2,3]{1,0} bitcast(param_0.1)
  zero = s32[] constant(0)
  param_1.1 = s32[] parameter(1)
  dynamic-slice = s32[1,1]{1,0} dynamic-slice(bitcast, param_1.1, zero), dynamic_slice_sizes={1,1}
  one = s32[] constant(1)
  bitcasted_one = s32[1,1]{1,0} bitcast(one)
  add = s32[1,1] add(dynamic-slice, bitcasted_one)
  dynamic-update-slice = s32[2,3]{1,0} dynamic-update-slice(bitcast, add, param_1.1, zero)
  ROOT bitcast.1 = s32[6]{0} bitcast(dynamic-update-slice)
}

ENTRY main {
  param_0 = s32[6]{0} parameter(0)
  param_1 = s32[] parameter(1)
  ROOT fusion = s32[6]{0} fusion(param_0, param_1), kind=kInput, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_multiple
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG4:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK:        %[[COND2:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND2]], label %[[DUS1:.*]].in_bounds-true, label %[[DUS1]].in_bounds-after
// CHECK:      [[DUS1]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_141:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG3]], i64 %[[VAL_141]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x bfloat]]], ptr %[[ARG0]], i64 0, i64 %[[VAL_185:.*]], i64 %[[VAL_187:.*]], i64 %[[VAL_189:.*]]
// CHECK:      [[DUS1]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_173:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG3]], i64 %[[VAL_173]]
// CHECK-DAG:    getelementptr inbounds [8 x [11 x [12 x bfloat]]], ptr %[[ARG2]], i64 0, i64 %[[VAL_208:.*]], i64 %[[VAL_210:.*]], i64 %[[VAL_212:.*]]

HloModule MultipleInplaceDus, is_scheduled=true, input_output_alias={ {0}: (0, {}), {1}: (2, {}) }

fused_computation {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p4, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p3)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  dus1 = bf16[8,11,12] dynamic-update-slice(p2, select, c0, c0, c0)
  ROOT tuple = (bf16[10,11,12], bf16[8,11,12]) tuple(dus0, dus1)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  ROOT fusion_root_multiple = (bf16[10,11,12], bf16[8,11,12]) fusion(p0, p1, p2, p3, p4), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_multiple_transpose_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG4:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK:        %[[COND2:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND2]], label %[[DUS1:.*]].in_bounds-true, label %[[DUS1]].in_bounds-after
// CHECK:      [[DUS1]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_247:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG3]], i64 %[[VAL_247]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x bfloat]]], ptr %[[ARG0]], i64 0, i64 %[[VAL_291:.*]], i64 %[[VAL_293:.*]], i64 %[[VAL_295:.*]]
// CHECK:      [[DUS1]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_279:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG3]], i64 %[[VAL_279]]
// CHECK-DAG:    getelementptr inbounds [8 x [11 x [12 x bfloat]]], ptr %[[ARG2]], i64 0, i64 %[[VAL_314:.*]], i64 %[[VAL_316:.*]], i64 %[[VAL_318:.*]]

HloModule MultipleInplaceDusWithTransposeBitcastToTheRoot, is_scheduled=true, input_output_alias={ {0}: (0, {}), {1}: (2, {}) }

fused_computation {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p4, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p3)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  bitcasted_dus0 = bf16[11,10,12] bitcast(dus0)
  dus1 = bf16[8,11,12] dynamic-update-slice(p2, select, c0, c0, c0)
  ROOT tuple = (bf16[11,10,12], bf16[8,11,12]) tuple(bitcasted_dus0, dus1)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[8,11,12] parameter(2)
  p3 = bf16[1,11,12] parameter(3)
  p4 = s32[] parameter(4)
  ROOT fusion_root_multiple_transpose_bitcast = (bf16[11,10,12], bf16[8,11,12]) fusion(p0, p1, p2, p3, p4), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-LABEL: @fusion_root_transpose_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_353:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG2]], i64 %[[VAL_353]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x bfloat]]], ptr %[[ARG0]], i64 0, i64 %[[VAL_366:.*]], i64 %[[VAL_368:.*]], i64 %[[VAL_370:.*]]

HloModule SingleInplaceDusWithTransposeBitcastToTheRoot, is_scheduled=true, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_transpose_bitcast {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[11,10,12] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_transpose_bitcast = bf16[11,10,12] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_transpose_bitcast
}

// -----

// CHECK-LABEL: @fusion_root_reshape_bitcast
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_408:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG2]], i64 %[[VAL_408:.*]]
// CHECK-DAG:    getelementptr inbounds [10 x [11 x [12 x bfloat]]], ptr %[[ARG0]], i64 0, i64 %[[VAL_421:.*]], i64 %[[VAL_423:.*]], i64 %[[VAL_425:.*]]

HloModule SingleInplaceDusWithReshapeBitcastToTheRoot, is_scheduled=true, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_reshape_bitcast {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  dus0 = bf16[10,11,12] dynamic-update-slice(p0, select, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[10,11,6,2] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_reshape_bitcast = bf16[10,11,6,2] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_reshape_bitcast
}

// -----

// CHECK-LABEL: @fusion_root_bitcast_both_ways
// CHECK-SAME: %[[ARG0:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG1:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG2:[A-Za-z0-9]*]],
// CHECK-SAME: %[[ARG3:[A-Za-z0-9]*]])
// CHECK:        %[[COND:[A-Za-z0-9]*]] = icmp ult i64 %[[LINEAR_INDEX:.*]], 132
// CHECK:        br i1 %[[COND]], label %[[DUS0:.*]].in_bounds-true, label %[[DUS0]].in_bounds-after
// CHECK:      [[DUS0]].in_bounds-after:
// CHECK-NEXT:   ret void
// CHECK:      [[DUS0]].in_bounds-true
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG1]], i64 %[[VAL_468:.*]]
// CHECK-DAG:    getelementptr bfloat, ptr %[[ARG2]], i64 %[[VAL_468]]
// CHECK-DAG:    getelementptr inbounds [10 x [6 x [2 x [11 x bfloat]]]], ptr %[[ARG0]], i64 0, i64 %[[VAL_483:.*]], i64 %[[VAL_485:.*]], i64 %[[VAL_487:.*]], i64 %[[VAL_489:.*]]

HloModule SingleInplaceDusWithBitcastToTheRootAndFromTheParameter, is_scheduled=true, input_output_alias={ {}: (0, {}) }

single_inplace_dus_with_bitcast_to_the_root_and_from_the_parameter {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  c0 = s32[] constant(0)
  cmp = pred[] compare(p3, c0), direction=EQ
  broadcast = pred[1,11,12] broadcast(cmp), dimensions={}
  select = bf16[1,11,12] select(broadcast, p1, p2)
  bitcasted_p0 = bf16[10,6,2,11] bitcast(p0)
  bitcasted_select = bf16[1,6,2,11] bitcast(select)
  dus0 = bf16[10,6,2,11] dynamic-update-slice(bitcasted_p0, bitcasted_select, c0, c0, c0, c0)
  ROOT bitcasted_dus0 = bf16[10,11,6,2] bitcast(dus0)
}

ENTRY main {
  p0 = bf16[10,11,12] parameter(0)
  p1 = bf16[1,11,12] parameter(1)
  p2 = bf16[1,11,12] parameter(2)
  p3 = s32[] parameter(3)
  ROOT fusion_root_bitcast_both_ways = bf16[10,11,6,2] fusion(p0, p1, p2, p3), kind=kLoop, calls=single_inplace_dus_with_bitcast_to_the_root_and_from_the_parameter
}
