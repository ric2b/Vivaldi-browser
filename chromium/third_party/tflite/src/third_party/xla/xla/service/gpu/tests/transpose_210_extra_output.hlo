// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: hlo-opt %s --platform=gpu --xla_gpu_mlir_emitter_level=0 --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb --split-input-file | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

HloModule Transpose, is_scheduled=true

%fused_computation {
  %p0 = f32[33,49,65] parameter(0)
  %neg = f32[33,49,65] negate(%p0)
  %transpose = f32[65,49,33] transpose(%p0), dimensions={2,1,0}
  ROOT %tuple = (f32[33,49,65], f32[65,49,33]) tuple(%neg, %transpose)
}

ENTRY main {
  %param = f32[33,49,65]{2,1,0} parameter(0)
  ROOT %fusion = (f32[33,49,65], f32[65,49,33]) fusion(%param), kind=kInput, calls=%fused_computation
}

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK-PTX:     %thread.id.x = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !2
// CHECK-GCN:     %thread.id.x = call i32 @llvm.amdgcn.workitem.id.x
// CHECK-PTX:     %block.id.x = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !3
// CHECK-GCN:     %block.id.x = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK:         %thread.id.0 = udiv i32 %thread.id.x, 32
// CHECK:         %thread.id.2 = urem i32 %thread.id.x, 32
// CHECK:         %lane_id = urem i32 %thread.id.x, 32
// CHECK:         %[[VAL_5:.*]] = udiv i32 %block.id.x, 1
// CHECK:         %[[VAL_6:.*]] = urem i32 %[[VAL_5]], 3
// CHECK:         %[[VAL_7:.*]] = udiv i32 %block.id.x, 3
// CHECK:         %[[VAL_8:.*]] = urem i32 %[[VAL_7]], 49
// CHECK:         %[[VAL_9:.*]] = udiv i32 %block.id.x, 147
// CHECK:         %[[VAL_10:.*]] = icmp eq i32 %[[VAL_9]], 1
// CHECK:         %tile_bound.0 = select i1 %[[VAL_10]], i32 1, i32 32
// CHECK:         %[[VAL_11:.*]] = icmp eq i32 %[[VAL_6]], 2
// CHECK:         %tile_bound.2 = select i1 %[[VAL_11]], i32 1, i32 32
// CHECK:         %tile_origin.0 = mul i32 %[[VAL_9]], 32
// CHECK:         %tile_origin.1 = mul i32 %[[VAL_8]], 1
// CHECK:         %tile_origin.2 = mul i32 %[[VAL_6]], 32
// CHECK:         store i32 %thread.id.0, ptr{{.*}} %[[VAL_3]], align 4
// CHECK:         br label %[[VAL_12:.*]]
// CHECK:       loop0.loop_header:                                ; preds = %[[VAL_13:.*]], %[[VAL_14:.*]]
// CHECK:         %[[VAL_15:.*]] = load i32, ptr{{.*}} %[[VAL_3]], align 4
// CHECK:         %[[VAL_16:.*]] = icmp uge i32 %[[VAL_15]], %tile_bound.0
// CHECK:         br i1 %[[VAL_16]], label %[[VAL_17:.*]], label %[[VAL_18:.*]]
// CHECK:       loop0.loop_body:                                  ; preds = %[[VAL_12]]
// CHECK:         %[[VAL_19:.*]] = add nuw nsw i32 %[[VAL_15]], 4
// CHECK:         store i32 %[[VAL_19]], ptr{{.*}} %[[VAL_3]], align 4
// CHECK:         store i32 %thread.id.2, ptr{{.*}} %[[VAL_2]], align 4
// CHECK:         br label %[[VAL_21:.*]]
// CHECK:       loop2.loop_header:                                ; preds = %[[VAL_22:.*]], %[[VAL_18]]
// CHECK:         %[[VAL_23:.*]] = load i32, ptr{{.*}} %[[VAL_2]], align 4
// CHECK:         %[[VAL_24:.*]] = icmp uge i32 %[[VAL_23]], %tile_bound.2
// CHECK:         br i1 %[[VAL_24]], label %[[VAL_13]], label %[[VAL_22]]
// CHECK:       loop2.loop_body:                                  ; preds = %[[VAL_21]]
// CHECK:         %[[VAL_25:.*]] = add nuw nsw i32 %[[VAL_23]], 32
// CHECK:         store i32 %[[VAL_25]], ptr{{.*}} %[[VAL_2]], align 4
// CHECK:         %[[VAL_27:.*]] = add i32 %tile_origin.0, %[[VAL_15]]
// CHECK:         %[[VAL_28:.*]] = add i32 %tile_origin.1, 0
// CHECK:         %[[VAL_29:.*]] = add i32 %tile_origin.2, %[[VAL_23]]
// CHECK:         %[[VAL_30:.*]] = getelementptr inbounds [33 x [49 x [65 x float]]], ptr{{.*}} %[[VAL_31:.*]], i32 0, i32 %[[VAL_27]], i32 %[[VAL_28]], i32 %[[VAL_29]]
// CHECK:         %[[VAL_32:.*]] = load float, ptr{{.*}} %[[VAL_30]], align 4, !invariant.load !{{[0-9]}}
// CHECK:         %[[VAL_33:.*]] = getelementptr inbounds [32 x [1 x [33 x float]]], ptr{{.*}} addrspace(3) @tr_tile_0, i32 0, i32 %[[VAL_15]], i32 0, i32 %[[VAL_23]]
// CHECK:         %[[VAL_34:.*]] = addrspacecast ptr{{.*}} addrspace(3) %[[VAL_33]] to ptr
// CHECK:         store float %[[VAL_32]], ptr{{.*}} %[[VAL_34]], align 4
// CHECK:         %[[VAL_35:.*]] = getelementptr inbounds [33 x [49 x [65 x float]]], ptr{{.*}} %[[VAL_31]], i32 0, i32 %[[VAL_27]], i32 %[[VAL_28]], i32 %[[VAL_29]]
// CHECK:         %[[VAL_36:.*]] = load float, ptr{{.*}} %[[VAL_35]], align 4, !invariant.load !{{[0-9]}}
// CHECK:         %[[VAL_37:.*]] = fneg float %[[VAL_36]]
// CHECK:         %[[VAL_38:.*]] = getelementptr inbounds [33 x [49 x [65 x float]]], ptr{{.*}} %[[VAL_39:.*]], i32 0, i32 %[[VAL_27]], i32 %[[VAL_28]], i32 %[[VAL_29]]
// CHECK:         store float %[[VAL_37]], ptr{{.*}} %[[VAL_38]], align 4
// CHECK:         br label %[[VAL_21]], !llvm.loop !{{[0-9]}}
// CHECK:       loop2.loop_exit:                                  ; preds = %[[VAL_21]]
// CHECK:         br label %[[VAL_12]], !llvm.loop !{{[0-9]}}
// CHECK:       loop0.loop_exit:                                  ; preds = %[[VAL_12]]
// CHECK-PTX:     call void @llvm.nvvm.barrier0()
// CHECK-GCN:     call void @llvm.amdgcn.s.barrier()
// CHECK:         store i32 %thread.id.0, ptr{{.*}} %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_40:.*]]
// CHECK:       loop0.loop_header6:                               ; preds = %[[VAL_41:.*]], %[[VAL_17]]
// CHECK:         %[[VAL_42:.*]] = load i32, ptr{{.*}} %[[VAL_1]], align 4
// CHECK:         %[[VAL_43:.*]] = icmp uge i32 %[[VAL_42]], %tile_bound.2
// CHECK:         br i1 %[[VAL_43]], label %[[VAL_44:.*]], label %[[VAL_45:.*]]
// CHECK:       loop0.loop_body7:                                 ; preds = %[[VAL_40]]
// CHECK:         %[[VAL_46:.*]] = add nuw nsw i32 %[[VAL_42]], 4
// CHECK:         store i32 %[[VAL_46]], ptr{{.*}} %[[VAL_1]], align 4
// CHECK:         store i32 %thread.id.2, ptr{{.*}} %[[VAL_0]], align 4
// CHECK:         br label %[[VAL_48:.*]]
// CHECK:       loop2.loop_header12:                              ; preds = %[[VAL_49:.*]], %[[VAL_45]]
// CHECK:         %[[VAL_50:.*]] = load i32, ptr{{.*}} %[[VAL_0]], align 4
// CHECK:         %[[VAL_51:.*]] = icmp uge i32 %[[VAL_50]], %tile_bound.0
// CHECK:         br i1 %[[VAL_51]], label %[[VAL_41]], label %[[VAL_49]]
// CHECK:       loop2.loop_body13:                                ; preds = %[[VAL_48]]
// CHECK:         %[[VAL_52:.*]] = add nuw nsw i32 %[[VAL_50]], 32
// CHECK:         store i32 %[[VAL_52]], ptr{{.*}} %[[VAL_0]], align 4
// CHECK:         %[[VAL_54:.*]] = add i32 %tile_origin.2, %[[VAL_42]]
// CHECK:         %[[VAL_55:.*]] = add i32 %tile_origin.1, 0
// CHECK:         %[[VAL_56:.*]] = add i32 %tile_origin.0, %[[VAL_50]]
// CHECK:         %[[VAL_57:.*]] = getelementptr inbounds [32 x [1 x [33 x float]]], ptr{{.*}} addrspace(3) @tr_tile_0, i32 0, i32 %[[VAL_50]], i32 0, i32 %[[VAL_42]]
// CHECK:         %[[VAL_58:.*]] = addrspacecast ptr{{.*}} addrspace(3) %[[VAL_57]] to ptr
// CHECK:         %[[VAL_59:.*]] = load float, ptr{{.*}} %[[VAL_58]], align 4
// CHECK:         %[[VAL_60:.*]] = getelementptr inbounds [65 x [49 x [33 x float]]], ptr{{.*}} %[[VAL_61:.*]], i32 0, i32 %[[VAL_54]], i32 %[[VAL_55]], i32 %[[VAL_56]]
// CHECK:         store float %[[VAL_59]], ptr{{.*}} %[[VAL_60]], align 4
// CHECK:         br label %[[VAL_48]], !llvm.loop !{{[0-9]}}
// CHECK:       loop2.loop_exit11:                                ; preds = %[[VAL_48]]
// CHECK:         br label %[[VAL_40]], !llvm.loop !{{[0-9]}}
// CHECK:       loop0.loop_exit5:                                 ; preds = %[[VAL_40]]
// CHECK:         ret void
