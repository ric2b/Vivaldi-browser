// RUN: hlo-opt %s --xla_gpu_mlir_emitter_level=0 --platform=gpu --stage=llvm-before-optimizations --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/%{GPU}.txtpb | FileCheck --check-prefixes=CHECK,CHECK-%{PTX} %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
// CHECK-PTX:     %[[VAL_1:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x
// CHECK-GCN:     %[[VAL_1:.*]] = call i32 @llvm.amdgcn.workgroup.id.x
// CHECK-PTX:     %[[VAL_2:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x
// CHECK-GCN:     %[[VAL_2:.*]] = call i32 @llvm.amdgcn.workitem.id.x
// CHECK:         %[[VAL_3:.*]] = mul nuw nsw i32 %[[VAL_1]], 6
// CHECK:         %[[VAL_4:.*]] = add nuw nsw i32 %[[VAL_3]], %[[VAL_2]]
// CHECK:         %[[VAL_5:.*]] = icmp ult i32 %[[VAL_4]], 6
// CHECK:         call void @llvm.assume(i1 %[[VAL_5]])
// CHECK:         %[[VAL_6:.*]] = add nuw nsw i32 %[[VAL_4]], 0
// CHECK:         %[[VAL_7:.*]] = udiv i32 %[[VAL_6]], 1
// CHECK:         %[[VAL_8:.*]] = urem i32 %[[VAL_7]], 3
// CHECK:         %[[VAL_9:.*]] = udiv i32 %[[VAL_6]], 3
// CHECK:         %[[VAL_10:.*]] = urem i32 %[[VAL_9]], 1
// CHECK:         %[[VAL_11:.*]] = udiv i32 %[[VAL_6]], 3
// CHECK:         %[[VAL_12:.*]] = icmp ult i32 %[[VAL_4]], 6
// CHECK:         br i1 %[[VAL_12]], label %[[VAL_13:.*]], label %[[VAL_14:.*]]
// CHECK:       scatter.in_bounds-after:                          ; preds = %[[VAL_15:.*]], %[[VAL_16:.*]]
// CHECK:         ret void
// CHECK:       scatter.in_bounds-true:                           ; preds = %[[VAL_16]]
// CHECK:         %[[VAL_17:.*]] = getelementptr inbounds [2 x [1 x i32]], ptr %[[VAL_18:.*]], i32 0, i32 %[[VAL_11]], i32 0
// CHECK:         %[[VAL_19:.*]] = load i32, ptr %[[VAL_17]], align 4, !invariant.load !10
// CHECK:         %[[VAL_20:.*]] = add i32 %[[VAL_10]], %[[VAL_19]]
// CHECK:         %[[VAL_21:.*]] = icmp ult i32 %[[VAL_19]], 3
// CHECK:         %[[VAL_22:.*]] = and i1 true, %[[VAL_21]]
// CHECK:         br i1 %[[VAL_22]], label %[[VAL_23:.*]], label %[[VAL_15]]
// CHECK:       scatter.in_bounds-after3:                         ; preds = %[[VAL_23]], %[[VAL_13]]
// CHECK:         br label %[[VAL_14]]
// CHECK:       scatter.in_bounds-true2:                          ; preds = %[[VAL_13]]
// CHECK:         %[[VAL_24:.*]] = getelementptr inbounds [3 x [3 x i32]], ptr %[[VAL_25:.*]], i32 0, i32 %[[VAL_20]], i32 %[[VAL_8]]
// CHECK:         %[[VAL_26:.*]] = getelementptr i32, ptr %[[VAL_27:.*]], i32 %[[VAL_4]]
// CHECK:         %[[VAL_28:.*]] = getelementptr inbounds i32, ptr %[[VAL_26]], i32 0
// CHECK:         %[[VAL_29:.*]] = load i32, ptr %[[VAL_28]], align 4, !invariant.load !10
// CHECK:         store i32 %[[VAL_29]], ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_30:.*]] = load i32, ptr %[[VAL_0]], align 4
// CHECK:         store atomic i32 %[[VAL_30]], ptr %[[VAL_24]] unordered, align 4
// CHECK:         br label %[[VAL_15]]

HloModule TensorFlowScatterV1, is_scheduled=true

update_s32 (lhs: s32[], rhs: s32[]) -> s32[] {
  lhs = s32[] parameter(0)
  ROOT rhs = s32[] parameter(1)
}

fused_computation {
  param_0 = s32[3,3]{1,0} parameter(0)
  ROOT operand.1 = s32[3,3]{1,0} add(param_0, param_0)
}

fused_computation.1 {
  param_0.1 = s32[2,1]{1,0} parameter(0)
  ROOT indices.1 = s32[2,1]{1,0} add(param_0.1, param_0.1)
}

fused_computation.2 {
  param_0.2 = s32[2,1,3]{2,1,0} parameter(0)
  ROOT updates.1 = s32[2,1,3]{2,1,0} add(param_0.2, param_0.2)
}

fused_computation.3 {
  operand = s32[3,3]{1,0} parameter(0)
  indices = s32[2,1]{1,0} parameter(1)
  updates = s32[2,1,3]{2,1,0} parameter(2)
  ROOT scatter = s32[3,3] scatter(operand, indices, updates),
      to_apply=update_s32,
      update_window_dims={1,2},
      inserted_window_dims={},
      scatter_dims_to_operand_dims={0},
      index_vector_dim=1
}

ENTRY main {
  p1 = s32[2,1] parameter(1)
  wrapped_indices = s32[2,1]{1,0} fusion(p1), kind=kLoop, calls=fused_computation.1
  p2 = s32[2,1,3] parameter(2)
  wrapped_updates = s32[2,1,3]{2,1,0} fusion(p2), kind=kLoop, calls=fused_computation.2
  p0 = s32[3,3] parameter(0)
  wrapped_operand = s32[3,3]{1,0} fusion(p0), kind=kLoop, calls=fused_computation
  ROOT wrapped_scatter = s32[3,3] fusion(wrapped_operand, wrapped_indices, wrapped_updates), kind=kInput, calls=fused_computation.3
}
