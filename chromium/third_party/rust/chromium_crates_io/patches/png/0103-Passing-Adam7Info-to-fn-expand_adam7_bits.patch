From fa12d377c046bbb1e20805552cf4866977ba3c77 Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Thu, 29 Aug 2024 19:02:27 +0000
Subject: [PATCH 103/107] Passing `&Adam7Info` to `fn expand_adam7_bits`.

Instead of passing `line_no` and `pass` as separate parameters, we
can pass a single `&Adam7Info` parameter.  This minor refactoring
helps with:

* Cleaning up `fn expand_pass` by moving some of its complexity closer
  to where its needed (within `fn expand_adam7_bits`)
* Preparing for changing the semantics of the `width` parameter of
  `fn expand_adam7_bits` in a follow-up commit, where we will stop
  depending on `width` for calculating the length of the returned
  iterator (depending on `Adam7Info.width` instead).  See the follow-up
  commit for more details.
---
 src/adam7.rs | 46 ++++++++++++++++++++++------------------------
 1 file changed, 22 insertions(+), 24 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
index 213bb6d..51667f7 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
@@ -117,14 +117,13 @@ fn subbyte_pixels(scanline: &[u8], bits_pp: usize) -> impl Iterator<Item = u8> +
         })
 }
 
-/// Given pass, image width, and line number, produce an iterator of bit positions of pixels to copy
-/// from the input scanline to the image buffer.
-fn expand_adam7_bits(
-    pass: u8,
-    width: usize,
-    line_no: usize,
-    bits_pp: usize,
-) -> StepBy<Range<usize>> {
+/// Given image `width`, interlace `info`, and bits-per-pixel, produce an iterator of bit positions
+/// of pixels to copy from the input scanline to the image buffer.  The positions are expressed as
+/// bit offsets from position (0,0) in the frame that is currently being decoded.
+fn expand_adam7_bits(width: usize, info: &Adam7Info, bits_pp: usize) -> StepBy<Range<usize>> {
+    let line_no = info.line as usize;
+    let pass = info.pass;
+
     let (line_mul, line_off, samp_mul, samp_off) = match pass {
         1 => (8, 0, 8, 0),
         2 => (8, 0, 8, 4),
@@ -133,7 +132,11 @@ fn expand_adam7_bits(
         5 => (4, 2, 2, 0),
         6 => (2, 0, 2, 1),
         7 => (2, 1, 1, 0),
-        _ => panic!("Adam7 pass out of range: {}", pass),
+        _ => {
+            // `Adam7Info.pass` is a non-`pub`lic field.  `InterlaceInfo` is expected
+            // to maintain an invariant that `pass` is valid.
+            panic!("Invalid `Adam7Info.pass`");
+        }
     };
 
     // the equivalent line number in progressive scan
@@ -150,16 +153,9 @@ fn expand_adam7_bits(
 /// Expands an Adam 7 pass
 pub fn expand_pass(img: &mut [u8], width: u32, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
     let width = width as usize;
-    let line_no = info.line as usize;
-    let pass = info.pass;
     let bits_pp = bits_pp as usize;
 
-    // pass is out of range but don't blow up
-    if pass == 0 || pass > 7 {
-        return;
-    }
-
-    let bit_indices = expand_adam7_bits(pass, width, line_no, bits_pp);
+    let bit_indices = expand_adam7_bits(width, info, bits_pp);
 
     if bits_pp < 8 {
         for (pos, px) in bit_indices.zip(subbyte_pixels(scanline, bits_pp)) {
@@ -242,6 +238,8 @@ fn test_subbyte_pixels() {
 fn test_expand_adam7_bits() {
     let width = 32;
     let bits_pp = 1;
+    let info =
+        |pass, line, img_width| create_adam7_info_for_tests(pass, line as u32, img_width as u32);
 
     let expected = |offset: usize, step: usize, count: usize| {
         (0..count)
@@ -253,21 +251,21 @@ fn test_expand_adam7_bits() {
         let start = 8 * line_no * width;
 
         assert_eq!(
-            expand_adam7_bits(1, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(1, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 8, 4)
         );
 
         let start = start + 4;
 
         assert_eq!(
-            expand_adam7_bits(2, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(2, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 8, 4)
         );
 
         let start = (8 * line_no + 4) * width;
 
         assert_eq!(
-            expand_adam7_bits(3, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(3, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 4, 8)
         );
     }
@@ -276,14 +274,14 @@ fn test_expand_adam7_bits() {
         let start = 4 * line_no * width + 2;
 
         assert_eq!(
-            expand_adam7_bits(4, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(4, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 4, 8)
         );
 
         let start = (4 * line_no + 2) * width;
 
         assert_eq!(
-            expand_adam7_bits(5, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(5, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 2, 16)
         )
     }
@@ -292,7 +290,7 @@ fn test_expand_adam7_bits() {
         let start = 2 * line_no * width + 1;
 
         assert_eq!(
-            expand_adam7_bits(6, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(6, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 2, 16),
             "line_no: {}",
             line_no
@@ -301,7 +299,7 @@ fn test_expand_adam7_bits() {
         let start = (2 * line_no + 1) * width;
 
         assert_eq!(
-            expand_adam7_bits(7, width, line_no, bits_pp).collect::<Vec<_>>(),
+            expand_adam7_bits(width, &info(7, line_no, width), bits_pp).collect::<Vec<_>>(),
             expected(start, 1, 32)
         );
     }
-- 
2.46.0.598.g6f2099f65c-goog

