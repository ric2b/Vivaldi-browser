From a8606523dc284a0432c9b1737066b189ca3ea660 Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Fri, 30 Aug 2024 19:19:17 +0000
Subject: [PATCH 101/107] Introduce a separate `struct Adam7Info`.

This helps with the following things:

* It means that after making `InterlaceInfo` public in a follow-up
  commit, `pass`, `line`, and `width` fields can remain private.
* It means that a follow-up commit that refactors `adam7::expand_pass`
  to take a single `info` parameter doesn't allow passing an
  invalid `InterlaceInfo::Null` value.
* It gives `Adam7Iterator` a nicer, named `Iterator::Item`.
---
 src/adam7.rs       | 67 ++++++++++++++++++++++++++++++++++++++--------
 src/decoder/mod.rs | 32 +++++++++++++---------
 2 files changed, 76 insertions(+), 23 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
index 5bf7bb3..550e215 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
@@ -1,7 +1,20 @@
-//! Utility functions
+//! Utility functions related to handling of
+//! [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm).
 use std::iter::StepBy;
 use std::ops::Range;
 
+/// Describes which stage of
+/// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
+/// applies to a decoded row.
+///
+/// See also [Reader::next_interlaced_row].
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub struct Adam7Info {
+    pub(crate) pass: u8,
+    pub(crate) line: u32,
+    pub(crate) width: u32,
+}
+
 /// This iterator iterates over the different passes of an image Adam7 encoded
 /// PNG image
 /// The pattern is:
@@ -63,14 +76,18 @@ impl Adam7Iterator {
     }
 }
 
-/// Iterates over the (passes, lines, widths)
+/// Iterates over `Adam7Info`s.
 impl Iterator for Adam7Iterator {
-    type Item = (u8, u32, u32);
+    type Item = Adam7Info;
     fn next(&mut self) -> Option<Self::Item> {
         if self.line < self.lines && self.line_width > 0 {
             let this_line = self.line;
             self.line += 1;
-            Some((self.current_pass, this_line, self.line_width))
+            Some(Adam7Info {
+                pass: self.current_pass,
+                line: this_line,
+                width: self.line_width,
+            })
         } else if self.current_pass < 7 {
             self.current_pass += 1;
             self.init_pass();
@@ -179,13 +196,41 @@ fn test_adam7() {
     assert_eq!(
         &*passes,
         &[
-            (1, 0, 1),
-            (4, 0, 1),
-            (5, 0, 2),
-            (6, 0, 2),
-            (6, 1, 2),
-            (7, 0, 4),
-            (7, 1, 4)
+            Adam7Info {
+                pass: 1,
+                line: 0,
+                width: 1
+            },
+            Adam7Info {
+                pass: 4,
+                line: 0,
+                width: 1
+            },
+            Adam7Info {
+                pass: 5,
+                line: 0,
+                width: 2
+            },
+            Adam7Info {
+                pass: 6,
+                line: 0,
+                width: 2
+            },
+            Adam7Info {
+                pass: 6,
+                line: 1,
+                width: 2
+            },
+            Adam7Info {
+                pass: 7,
+                line: 0,
+                width: 4
+            },
+            Adam7Info {
+                pass: 7,
+                line: 1,
+                width: 4
+            }
         ]
     );
 }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
index 2a18964..a5f2e70 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
@@ -99,19 +99,26 @@ impl<'data> InterlacedRow<'data> {
         self.data
     }
 
-    pub fn interlace(&self) -> InterlaceInfo {
-        self.interlace
+    pub fn interlace(&self) -> &InterlaceInfo {
+        &self.interlace
     }
 }
 
+/// Describes which interlacing algorithm applies to a decoded row.
+///
 /// PNG (2003) specifies two interlace modes, but reserves future extensions.
+///
+/// See also [Reader::next_interlaced_row].
 #[derive(Clone, Copy, Debug)]
 pub enum InterlaceInfo {
-    /// the null method means no interlacing
+    /// The `null` method means no interlacing.
     Null,
-    /// Adam7 derives its name from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
-    /// The following table shows pictorially what parts of each 8x8 area of the image is found in each pass:
+    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
+    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
+    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
+    /// each pass:
     ///
+    /// ```txt
     /// 1 6 4 6 2 6 4 6
     /// 7 7 7 7 7 7 7 7
     /// 5 6 5 6 5 6 5 6
@@ -120,7 +127,8 @@ pub enum InterlaceInfo {
     /// 7 7 7 7 7 7 7 7
     /// 5 6 5 6 5 6 5 6
     /// 7 7 7 7 7 7 7 7
-    Adam7 { pass: u8, line: u32, width: u32 },
+    /// ```
+    Adam7(adam7::Adam7Info),
 }
 
 /// A row of data without interlace information.
@@ -545,7 +553,7 @@ impl<R: Read> Reader<R> {
             }) = self.next_interlaced_row()?
             {
                 let (line, pass) = match interlace {
-                    InterlaceInfo::Adam7 { line, pass, .. } => (line, pass),
+                    InterlaceInfo::Adam7(adam7::Adam7Info { line, pass, .. }) => (line, pass),
                     InterlaceInfo::Null => unreachable!("expected interlace information"),
                 };
                 let samples = color_type.samples() as u8;
@@ -599,7 +607,7 @@ impl<R: Read> Reader<R> {
             None => return Ok(None),
         };
 
-        let width = if let InterlaceInfo::Adam7 { width, .. } = interlace {
+        let width = if let InterlaceInfo::Adam7(adam7::Adam7Info { width, .. }) = interlace {
             width
         } else {
             self.subframe.width
@@ -715,12 +723,12 @@ impl<R: Read> Reader<R> {
         match self.subframe.interlace {
             InterlaceIter::Adam7(ref mut adam7) => {
                 let last_pass = adam7.current_pass();
-                let (pass, line, width) = adam7.next()?;
-                let rowlen = self.info().raw_row_length_from_width(width);
-                if last_pass != pass {
+                let adam7info = adam7.next()?;
+                let rowlen = self.info().raw_row_length_from_width(adam7info.width);
+                if last_pass != adam7info.pass {
                     self.prev_start = self.current_start;
                 }
-                Some((rowlen, InterlaceInfo::Adam7 { pass, line, width }))
+                Some((rowlen, InterlaceInfo::Adam7(adam7info)))
             }
             InterlaceIter::None(ref mut height) => {
                 let _ = height.next()?;
-- 
2.46.0.598.g6f2099f65c-goog

