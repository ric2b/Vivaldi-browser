From 82547fcd38519ea1104e99ff58d0863fb304551f Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Thu, 29 Aug 2024 17:05:30 +0000
Subject: [PATCH 102/107] Passing `&Adam7Info` to `fn expand_pass`.

Instead of passing `line_no` and `pass` as separate parameters, we
can pass a single `&Adam7Info` parameter.  This minor refactoring
helps with:

* Exposing a nice public API in a follow-up commit
* Depending on `Adam7Info.width` in a follow-up commit
---
 src/adam7.rs       | 57 +++++++++++++++++++++++++++-------------------
 src/decoder/mod.rs | 22 ++++++++++++------
 2 files changed, 48 insertions(+), 31 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
index 550e215..213bb6d 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
@@ -148,16 +148,10 @@ fn expand_adam7_bits(
 }
 
 /// Expands an Adam 7 pass
-pub fn expand_pass(
-    img: &mut [u8],
-    width: u32,
-    scanline: &[u8],
-    pass: u8,
-    line_no: u32,
-    bits_pp: u8,
-) {
+pub fn expand_pass(img: &mut [u8], width: u32, scanline: &[u8], info: &Adam7Info, bits_pp: u8) {
     let width = width as usize;
-    let line_no = line_no as usize;
+    let line_no = info.line as usize;
+    let pass = info.pass;
     let bits_pp = bits_pp as usize;
 
     // pass is out of range but don't blow up
@@ -318,56 +312,57 @@ fn test_expand_pass_subbyte() {
     let mut img = [0u8; 8];
     let width = 8;
     let bits_pp = 1;
+    let info = create_adam7_info_for_tests;
 
-    expand_pass(&mut img, width, &[0b10000000], 1, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b10000000], &info(1, 0, width), bits_pp);
     assert_eq!(img, [0b10000000u8, 0, 0, 0, 0, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b10000000], 2, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b10000000], &info(2, 0, width), bits_pp);
     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b11000000], 3, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b11000000], &info(3, 0, width), bits_pp);
     assert_eq!(img, [0b10001000u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b11000000], 4, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b11000000], &info(4, 0, width), bits_pp);
     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10001000, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b11000000], 4, 1, bits_pp);
+    expand_pass(&mut img, width, &[0b11000000], &info(4, 1, width), bits_pp);
     assert_eq!(img, [0b10101010u8, 0, 0, 0, 0b10101010, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b11110000], 5, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(5, 0, width), bits_pp);
     assert_eq!(img, [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0, 0]);
 
-    expand_pass(&mut img, width, &[0b11110000], 5, 1, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(5, 1, width), bits_pp);
     assert_eq!(
         img,
         [0b10101010u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
     );
 
-    expand_pass(&mut img, width, &[0b11110000], 6, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(6, 0, width), bits_pp);
     assert_eq!(
         img,
         [0b11111111u8, 0, 0b10101010, 0, 0b10101010, 0, 0b10101010, 0]
     );
 
-    expand_pass(&mut img, width, &[0b11110000], 6, 1, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(6, 1, width), bits_pp);
     assert_eq!(
         img,
         [0b11111111u8, 0, 0b11111111, 0, 0b10101010, 0, 0b10101010, 0]
     );
 
-    expand_pass(&mut img, width, &[0b11110000], 6, 2, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(6, 2, width), bits_pp);
     assert_eq!(
         img,
         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b10101010, 0]
     );
 
-    expand_pass(&mut img, width, &[0b11110000], 6, 3, bits_pp);
+    expand_pass(&mut img, width, &[0b11110000], &info(6, 3, width), bits_pp);
     assert_eq!(
         [0b11111111u8, 0, 0b11111111, 0, 0b11111111, 0, 0b11111111, 0],
         img
     );
 
-    expand_pass(&mut img, width, &[0b11111111], 7, 0, bits_pp);
+    expand_pass(&mut img, width, &[0b11111111], &info(7, 0, width), bits_pp);
     assert_eq!(
         [
             0b11111111u8,
@@ -382,7 +377,7 @@ fn test_expand_pass_subbyte() {
         img
     );
 
-    expand_pass(&mut img, width, &[0b11111111], 7, 1, bits_pp);
+    expand_pass(&mut img, width, &[0b11111111], &info(7, 1, width), bits_pp);
     assert_eq!(
         [
             0b11111111u8,
@@ -397,7 +392,7 @@ fn test_expand_pass_subbyte() {
         img
     );
 
-    expand_pass(&mut img, width, &[0b11111111], 7, 2, bits_pp);
+    expand_pass(&mut img, width, &[0b11111111], &info(7, 2, width), bits_pp);
     assert_eq!(
         [
             0b11111111u8,
@@ -412,7 +407,7 @@ fn test_expand_pass_subbyte() {
         img
     );
 
-    expand_pass(&mut img, width, &[0b11111111], 7, 3, bits_pp);
+    expand_pass(&mut img, width, &[0b11111111], &info(7, 3, width), bits_pp);
     assert_eq!(
         [
             0b11111111u8,
@@ -427,3 +422,17 @@ fn test_expand_pass_subbyte() {
         img
     );
 }
+
+#[cfg(test)]
+fn create_adam7_info_for_tests(pass: u8, line: u32, img_width: u32) -> Adam7Info {
+    let width = {
+        let img_height = 8;
+        Adam7Iterator::new(img_width, img_height)
+            .filter(|info| info.pass == pass)
+            .map(|info| info.width)
+            .next()
+            .unwrap()
+    };
+
+    Adam7Info { pass, line, width }
+}
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
index a5f2e70..bbd5953 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
@@ -131,6 +131,15 @@ pub enum InterlaceInfo {
     Adam7(adam7::Adam7Info),
 }
 
+impl InterlaceInfo {
+    fn get_adam7_info(&self) -> Option<&adam7::Adam7Info> {
+        match self {
+            InterlaceInfo::Null => None,
+            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
+        }
+    }
+}
+
 /// A row of data without interlace information.
 #[derive(Clone, Copy, Debug)]
 pub struct Row<'data> {
@@ -544,20 +553,19 @@ impl<R: Read> Reader<R> {
         self.data_stream.clear();
         self.current_start = 0;
         self.prev_start = 0;
-        let width = self.info().width;
         if self.info().interlaced {
+            let width = self.info().width;
+            let samples = color_type.samples() as u8;
+            let bits_pp = samples * (bit_depth as u8);
             while let Some(InterlacedRow {
                 data: row,
                 interlace,
                 ..
             }) = self.next_interlaced_row()?
             {
-                let (line, pass) = match interlace {
-                    InterlaceInfo::Adam7(adam7::Adam7Info { line, pass, .. }) => (line, pass),
-                    InterlaceInfo::Null => unreachable!("expected interlace information"),
-                };
-                let samples = color_type.samples() as u8;
-                adam7::expand_pass(buf, width, row, pass, line, samples * (bit_depth as u8));
+                // `unwrap` won't panic, because we checked `self.info().interlaced` above.
+                let adam7info = interlace.get_adam7_info().unwrap();
+                adam7::expand_pass(buf, width, row, &adam7info, bits_pp);
             }
         } else {
             for row in buf
-- 
2.46.0.598.g6f2099f65c-goog

