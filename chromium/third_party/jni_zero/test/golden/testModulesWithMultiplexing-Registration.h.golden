// This file was generated by
//     //third_party/jni_zero/jni_zero.py
// For
//     J.module_N

#ifndef TEMP_DIR_HEADER_
#define TEMP_DIR_HEADER_

#include <iterator>

#include "third_party/jni_zero/jni_zero_internal.h"



// Forward declarations (methods).

JNI_POSSIBLE_BOUNDARY_EXPORT jboolean Java_org_1jni_11zero_1SampleModule_1bar(
    JNIEnv* env,
    jclass jcaller,
    jboolean a);
JNI_POSSIBLE_BOUNDARY_EXPORT void Java_org_1jni_11zero_1SampleModule_1foo(
    JNIEnv* env,
    jclass jcaller);


JNI_BOUNDARY_EXPORT jboolean Java_J_module_1N__1Z_1Z(
    JNIEnv* env,
    jclass jcaller,
    jint switch_num, jboolean jboolean_param1) {
        return Java_org_1jni_11zero_1SampleModule_1bar(env, jcaller, jboolean_param1);
}
JNI_BOUNDARY_EXPORT void Java_J_module_1N__1V(
    JNIEnv* env,
    jclass jcaller,
    jint switch_num) {
        return Java_org_1jni_11zero_1SampleModule_1foo(env, jcaller);
}
// Method declarations.


static const JNINativeMethod kMethods_J_module_1N[] = {
    { "_V", "(I)V", reinterpret_cast<void*>(Java_J_module_1N__1V) },
    { "_Z_Z", "(IZ)Z", reinterpret_cast<void*>(Java_J_module_1N__1Z_1Z) }
};

namespace {

JNI_ZERO_COMPONENT_BUILD_EXPORT bool RegisterNative_J_module_1N(JNIEnv* env) {
  const int number_of_methods = std::size(kMethods_J_module_1N);

  jni_zero::ScopedJavaLocalRef<jclass> native_clazz =
      jni_zero::GetClass(env, "J/module_N");
  if (env->RegisterNatives(
      native_clazz.obj(),
      kMethods_J_module_1N,
      number_of_methods) < 0) {

    jni_zero::internal::HandleRegistrationError(env, native_clazz.obj(), __FILE__);
    return false;
  }

  return true;
}

}  // namespace


// Registration function.

namespace  {

bool RegisterNatives(JNIEnv* env) {
  // Register natives in a proxy.
  if (!RegisterNative_J_module_1N(env)) {
    return false;
  }


  return true;
}

}  // namespace 


#endif  // TEMP_DIR_HEADER_

