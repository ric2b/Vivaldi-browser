// Copyright 2021 The Dawn & Tint Authors
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////////////////
// WGSL builtin definition file                                               //
//                                                                            //
// This file is used to generate parts of the Tint BuiltinTable, various      //
// enum definition files, as well as test .wgsl files.                        //
//                                                                            //
// After modifying this file, run:                                            //
//    tools/run gen                                                           //
// from the Dawn source directory.                                            //
//                                                                            //
// See docs/tint/intrinsic_definition_files.md for syntax                     //
////////////////////////////////////////////////////////////////////////////////

import "src/tint/lang/core/access.def"
import "src/tint/lang/core/address_space.def"
import "src/tint/lang/core/texel_format.def"

////////////////////////////////////////////////////////////////////////////////
// Enumerators                                                                //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#filterable-triggering-rules
enum core_diagnostic_rule {
  // Rules defined in the spec.
  derivative_uniformity
}

// chromium-specific diagnostics
enum chromium_diagnostic_rule {
  // Chromium specific rules not defined in the spec.
  unreachable_code
}

// https://gpuweb.github.io/gpuweb/wgsl/#syntax-severity_control_name
enum diagnostic_severity {
  error
  warning
  info
  off
}

// https://gpuweb.github.io/gpuweb/wgsl/#extension
enum extension {
  // WGSL Extension "f16"
  f16
  // WGSL Extension "dual_source_blending"
  dual_source_blending
  // WGSL Extension "subgroups"
  subgroups
  // WGSL Extension "subgroups_f16"
  subgroups_f16

  // A Chromium-specific extension for disabling uniformity analysis.
  chromium_disable_uniformity_analysis
  // A Chromium-specific extension for push constants
  chromium_experimental_push_constant
  // A Chromium-specific extension that adds basic subgroup functionality.
  chromium_experimental_subgroups
  // A Chromium-specific extension that enables features for graphite
  chromium_internal_graphite
  // A Chromium-specific extension that enables features for input
  // attachments
  chromium_internal_input_attachments
  // A Chromium-specific extension that relaxes memory layout requirements for uniform storage.
  chromium_internal_relaxed_uniform_layout
  // A Chromium-specific extension that enables pixel local storage.
  // Cannot be used with chromium_experimental_framebuffer_fetch
  chromium_experimental_pixel_local
  // A Chromium-specific extension that enables framebuffer fetching.
  // Cannot be used with chromium_experimental_pixel_local
  chromium_experimental_framebuffer_fetch
}

// https://gpuweb.github.io/gpuweb/wgsl/#language-extensions-sec
enum language_feature {
  packed_4x8_integer_dot_product
  pointer_composite_access
  readonly_and_readwrite_storage_textures
  unrestricted_pointer_parameters

  // Language features used only for testing whose status will never change.
  chromium_testing_unimplemented
  chromium_testing_unsafe_experimental
  chromium_testing_experimental
  chromium_testing_shipped_with_killswitch
  chromium_testing_shipped
}

////////////////////////////////////////////////////////////////////////////////
// WGSL primitive types                                                       //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#plain-types-section
type bool
@precedence(5) @display("abstract-int")   type ia
@precedence(4) @display("abstract-float") type fa
@precedence(3) type i32
@precedence(2) type u32
@precedence(1) type f32
@precedence(0) type f16
type vec2<T>
type vec3<T>
type vec4<T>
type mat2x2<T>
type mat2x3<T>
type mat2x4<T>
type mat3x2<T>
type mat3x3<T>
type mat3x4<T>
type mat4x2<T>
type mat4x3<T>
type mat4x4<T>
@display("vec{N}<{T}>")     type vec<N: num, T>
@display("mat{N}x{M}<{T}>") type mat<N: num, M: num, T>
type ptr<S: address_space, T, A: access>
type ref<S: address_space, T, A: access>
type atomic<T>
type array<T>
type sampler
type sampler_comparison
type texture_1d<T>
type texture_2d<T>
type texture_2d_array<T>
type texture_3d<T>
type texture_cube<T>
type texture_cube_array<T>
type texture_multisampled_2d<T>
type texture_depth_2d
type texture_depth_2d_array
type texture_depth_cube
type texture_depth_cube_array
type texture_depth_multisampled_2d
type texture_storage_1d<F: texel_format, A: access>
type texture_storage_2d<F: texel_format, A: access>
type texture_storage_2d_array<F: texel_format, A: access>
type texture_storage_3d<F: texel_format, A: access>
type texture_external
type packedVec3<T>
type input_attachment<T>

@display("__modf_result_{T}")        type __modf_result<T>
@display("__modf_result_vec{N}_{T}") type __modf_result_vec<N: num, T>
@display("__frexp_result_{T}")        type __frexp_result<T>
@display("__frexp_result_vec{N}_{T}") type __frexp_result_vec<N: num, T>

type __atomic_compare_exchange_result<T>

////////////////////////////////////////////////////////////////////////////////
// Type matchers                                                              //
////////////////////////////////////////////////////////////////////////////////

match scalar: ia | fa | f32 | f16 | i32 | u32 | bool
match concrete_scalar: f32 | f16 | i32 | u32 | bool
match scalar_no_f32: ia | fa | i32 | f16 | u32 | bool
match scalar_no_f16: ia | fa | f32 | i32 | u32 | bool
match scalar_no_i32: ia | fa | f32 | f16 | u32 | bool
match scalar_no_u32: ia | fa | f32 | f16 | i32 | bool
match scalar_no_bool: ia | fa | f32 | f16 | i32 | u32
match fia_fiu32_f16: fa | ia | f32 | i32 | u32 | f16
match fia_fi32_f16: fa | ia | f32 | i32 | f16
match fia_fiu32: fa | ia | f32 | i32 | u32
match fa_f32: fa | f32
match fa_f32_f16: fa | f32 | f16
match ia_iu32: ia | i32 | u32
match ia_i32: ia | i32
match fiu32_f16: f32 | i32 | u32 | f16
match fiu32: f32 | i32 | u32
match fi32_f16: f32 | i32 | f16
match fi32: f32 | i32
match f32_f16: f32 | f16
match iu32: i32 | u32

////////////////////////////////////////////////////////////////////////////////
// Enum matchers                                                              //
//                                                                            //
// A number matcher that can match one or more enumerator values.             //
// All enumerator values listed in the match declaration need to be from the  //
// same enum.                                                                 //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#texel-formats
match f32_texel_format
  : texel_format.r8unorm
  | texel_format.bgra8unorm
  | texel_format.rgba8unorm
  | texel_format.rgba8snorm
  | texel_format.rgba16float
  | texel_format.r32float
  | texel_format.rg32float
  | texel_format.rgba32float
match i32_texel_format
  : texel_format.rgba8sint
  | texel_format.rgba16sint
  | texel_format.r32sint
  | texel_format.rg32sint
  | texel_format.rgba32sint
match u32_texel_format
  : texel_format.rgba8uint
  | texel_format.rgba16uint
  | texel_format.r32uint
  | texel_format.rg32uint
  | texel_format.rgba32uint

match read: access.read
match write: access.write
match read_write: access.read_write
match readable
  : access.read
  | access.read_write
match writable
  : access.write
  | access.read_write

match function_private_workgroup
  : address_space.function
  | address_space.private
  | address_space.workgroup
match workgroup_or_storage
  : address_space.workgroup
  | address_space.storage
match storage
  : address_space.storage
match workgroup
  : address_space.workgroup

////////////////////////////////////////////////////////////////////////////////
// Builtin Functions                                                          //
//                                                                            //
// Note: To help improve diagnostic messages, do not use type-matchers        //
// directly as parameter constraints. Instead use the constraint on an        //
// implicit template parameter. For example, instead of:                      //
//   fn F(scalar)                                                             //
// use:                                                                       //
//   fn F[S: scalar](S)                                                       //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#builtin-functions
@must_use @const fn abs[T: fia_fiu32_f16](T) -> T
@must_use @const fn abs[N: num, T: fia_fiu32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn acos[T: fa_f32_f16](@test_value(0.96891242171) T) -> T
@must_use @const fn acos[N: num, T: fa_f32_f16](@test_value(0.96891242171) vec<N, T>) -> vec<N, T>
@must_use @const fn acosh[T: fa_f32_f16](@test_value(1.5430806348) T) -> T
@must_use @const fn acosh[N: num, T: fa_f32_f16](@test_value(1.5430806348) vec<N, T>) -> vec<N, T>
@must_use @const fn all(bool) -> bool
@must_use @const fn all[N: num](vec<N, bool>) -> bool
@must_use @const fn any(bool) -> bool
@must_use @const fn any[N: num](vec<N, bool>) -> bool
@must_use fn arrayLength[T, R: read](ptr<storage, array<T>, R>) -> u32
@must_use @stage("fragment", "compute") fn arrayLength[T, W: writable](ptr<storage, array<T>, W>) -> u32
@must_use @const fn asin[T: fa_f32_f16](@test_value(0.479425538604) T) -> T
@must_use @const fn asin[N: num, T: fa_f32_f16](@test_value(0.479425538604) vec<N, T>) -> vec<N, T>
@must_use @const fn asinh[T: fa_f32_f16](T) -> T
@must_use @const fn asinh[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn atan[T: fa_f32_f16](T) -> T
@must_use @const fn atan[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn atan2[T: fa_f32_f16](T, T) -> T
@must_use @const fn atan2[T: fa_f32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn atanh[T: fa_f32_f16](@test_value(0.5) T) -> T
@must_use @const fn atanh[N: num, T: fa_f32_f16](@test_value(0.5) vec<N, T>) -> vec<N, T>
@must_use @const fn bitcast<T: fiu32>[U: fiu32](U) -> T
@must_use @const fn bitcast<T: f16>(f16) -> T
@must_use @const fn bitcast<T: vec<N, fiu32> >[N: num, U: fiu32](vec<N, U>) -> T
@must_use @const fn bitcast<T: vec<N, f16> >[N: num](vec<N, f16>) -> T
@must_use @const fn bitcast<T: u32>(ia) -> T
@must_use @const fn bitcast<T: vec<N, u32> >[N: num](vec<N, ia>) -> T
@must_use @const fn bitcast<T: fiu32>(vec2<f16>) -> T
@must_use @const fn bitcast<T: vec2<fiu32> >(vec4<f16>) -> T
@must_use @const fn bitcast<T: vec2<f16> >[S: fiu32](S) -> T
@must_use @const fn bitcast<T: vec4<f16> >[S: fiu32](vec2<S>) -> T
@must_use @const fn ceil[T: fa_f32_f16](@test_value(1.5) T) -> T
@must_use @const fn ceil[N: num, T: fa_f32_f16](@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const fn clamp[T: fia_fiu32_f16](T, T, T) -> T
@must_use @const fn clamp[T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn cos[T: fa_f32_f16](@test_value(0) T) -> T
@must_use @const fn cos[N: num, T: fa_f32_f16](@test_value(0) vec<N, T>) -> vec<N, T>
@must_use @const fn cosh[T: fa_f32_f16](@test_value(0) T) -> T
@must_use @const fn cosh[N: num, T: fa_f32_f16](@test_value(0) vec<N, T>) -> vec<N, T>
@must_use @const fn countLeadingZeros[T: iu32](T) -> T
@must_use @const fn countLeadingZeros[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn countOneBits[T: iu32](T) -> T
@must_use @const fn countOneBits[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn countTrailingZeros[T: iu32](T) -> T
@must_use @const fn countTrailingZeros[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn cross[T: fa_f32_f16](vec3<T>, vec3<T>) -> vec3<T>
@must_use @const fn degrees[T: fa_f32_f16](T) -> T
@must_use @const fn degrees[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn determinant[N: num, T: fa_f32_f16](mat<N, N, T>) -> T
@must_use @const fn distance[T: fa_f32_f16](T, T) -> T
@must_use @const fn distance[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>) -> T
@must_use @const fn dot[N: num, T: fia_fiu32_f16](vec<N, T>, vec<N, T>) -> T
@must_use @const fn dot4I8Packed(u32, u32) -> i32
@must_use @const fn dot4U8Packed(u32, u32) -> u32
@must_use @stage("fragment") fn dpdx(f32) -> f32
@must_use @stage("fragment") fn dpdx[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdxCoarse(f32) -> f32
@must_use @stage("fragment") fn dpdxCoarse[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdxFine(f32) -> f32
@must_use @stage("fragment") fn dpdxFine[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdy(f32) -> f32
@must_use @stage("fragment") fn dpdy[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdyCoarse(f32) -> f32
@must_use @stage("fragment") fn dpdyCoarse[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdyFine(f32) -> f32
@must_use @stage("fragment") fn dpdyFine[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @const fn exp[T: fa_f32_f16](T) -> T
@must_use @const fn exp[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn exp2[T: fa_f32_f16](T) -> T
@must_use @const fn exp2[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn extractBits[T: iu32](T, u32, u32) -> T
@must_use @const fn extractBits[N: num, T: iu32](vec<N, T>, u32, u32) -> vec<N, T>
@must_use @const fn faceForward[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn firstLeadingBit[T: iu32](T) -> T
@must_use @const fn firstLeadingBit[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn firstTrailingBit[T: iu32](T) -> T
@must_use @const fn firstTrailingBit[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn floor[T: fa_f32_f16](@test_value(1.5) T) -> T
@must_use @const fn floor[N: num, T: fa_f32_f16](@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const fn fma[T: fa_f32_f16](T, T, T) -> T
@must_use @const fn fma[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn fract[T: fa_f32_f16](@test_value(1.25) T) -> T
@must_use @const fn fract[N: num, T: fa_f32_f16](@test_value(1.25) vec<N, T>) -> vec<N, T>
@must_use @const fn frexp[T: fa_f32_f16](T) -> __frexp_result<T>
@must_use @const fn frexp[N: num, T: fa_f32_f16](vec<N, T>) -> __frexp_result_vec<N, T>
@must_use @stage("fragment") fn fwidth(f32) -> f32
@must_use @stage("fragment") fn fwidth[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn fwidthCoarse(f32) -> f32
@must_use @stage("fragment") fn fwidthCoarse[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn fwidthFine(f32) -> f32
@must_use @stage("fragment") fn fwidthFine[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @const fn insertBits[T: iu32](T, T, u32, u32) -> T
@must_use @const fn insertBits[N: num, T: iu32](vec<N, T>, vec<N, T>, u32, u32) -> vec<N, T>
@must_use @const fn inverseSqrt[T: fa_f32_f16](T) -> T
@must_use @const fn inverseSqrt[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn ldexp[T: fa_f32_f16, U: ia_i32](T, U) -> T
@must_use @const fn ldexp[N: num, T: fa_f32_f16, U: ia_i32](vec<N, T>, vec<N, U>) -> vec<N, T>
@must_use @const fn length[T: fa_f32_f16](@test_value(0.0) T) -> T
@must_use @const fn length[N: num, T: fa_f32_f16](@test_value(0.0) vec<N, T>) -> T
@must_use @const fn log[T: fa_f32_f16](T) -> T
@must_use @const fn log[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn log2[T: fa_f32_f16](T) -> T
@must_use @const fn log2[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn max[T: fia_fiu32_f16](T, T) -> T
@must_use @const fn max[N: num, T: fia_fiu32_f16](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn min[T: fia_fiu32_f16](T, T) -> T
@must_use @const fn min[N: num, T: fia_fiu32_f16](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn mix[T: fa_f32_f16](T, T, T) -> T
@must_use @const fn mix[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn mix[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>, T) -> vec<N, T>
@must_use @const fn modf[T: fa_f32_f16](@test_value(-1.5) T) -> __modf_result<T>
@must_use @const fn modf[N: num, T: fa_f32_f16](@test_value(-1.5) vec<N, T>) -> __modf_result_vec<N, T>
@must_use @const fn normalize[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn pack2x16float(vec2<f32>) -> u32
@must_use @const fn pack2x16snorm(vec2<f32>) -> u32
@must_use @const fn pack2x16unorm(vec2<f32>) -> u32
@must_use @const fn pack4x8snorm(vec4<f32>) -> u32
@must_use @const fn pack4x8unorm(vec4<f32>) -> u32
@must_use @const fn pack4xI8(vec4<i32>) -> u32
@must_use @const fn pack4xU8(vec4<u32>) -> u32
@must_use @const fn pack4xI8Clamp(vec4<i32>) -> u32
@must_use @const fn pack4xU8Clamp(vec4<u32>) -> u32
@must_use @const fn pow[T: fa_f32_f16](T, T) -> T
@must_use @const fn pow[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn quantizeToF16(f32) -> f32
@must_use @const fn quantizeToF16[N: num](vec<N, f32>) -> vec<N, f32>
@must_use @const fn radians[T: fa_f32_f16](T) -> T
@must_use @const fn radians[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn reflect[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn refract[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>, T) -> vec<N, T>
@must_use @const fn reverseBits[T: iu32](T) -> T
@must_use @const fn reverseBits[N: num, T: iu32](vec<N, T>) -> vec<N, T>
@must_use @const fn round[T: fa_f32_f16](@test_value(3.5) T) -> T
@must_use @const fn round[N: num, T: fa_f32_f16](@test_value(3.5) vec<N, T>) -> vec<N, T>
@must_use @const fn saturate[T: fa_f32_f16](@test_value(2) T) -> T
@must_use @const fn saturate[T: fa_f32_f16, N: num](@test_value(2) vec<N, T>) -> vec<N, T>
@must_use @const("select_bool") fn select[T: scalar](T, T, bool) -> T
@must_use @const("select_bool") fn select[T: scalar, N: num](vec<N, T>, vec<N, T>, bool) -> vec<N, T>
@must_use @const("select_boolvec") fn select[N: num, T: scalar](vec<N, T>, vec<N, T>, vec<N, bool>) -> vec<N, T>
@must_use @const fn sign[T: fia_fi32_f16](T) -> T
@must_use @const fn sign[N: num, T: fia_fi32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn sin[T: fa_f32_f16](@test_value(1.57079632679) T) -> T
@must_use @const fn sin[N: num, T: fa_f32_f16](@test_value(1.57079632679) vec<N, T>) -> vec<N, T>
@must_use @const fn sinh[T: fa_f32_f16](T) -> T
@must_use @const fn sinh[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn smoothstep[T: fa_f32_f16](@test_value(2) T, @test_value(4) T, @test_value(3) T) -> T
@must_use @const fn smoothstep[N: num, T: fa_f32_f16](@test_value(2) vec<N, T>, @test_value(4) vec<N, T>, @test_value(3) vec<N, T>) -> vec<N, T>
@must_use @const fn sqrt[T: fa_f32_f16](T) -> T
@must_use @const fn sqrt[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn step[T: fa_f32_f16](T, T) -> T
@must_use @const fn step[N: num, T: fa_f32_f16](vec<N, T>, vec<N, T>) -> vec<N, T>
@stage("compute") fn storageBarrier()
@must_use @const fn tan[T: fa_f32_f16](T) -> T
@must_use @const fn tan[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn tanh[T: fa_f32_f16](T) -> T
@must_use @const fn tanh[N: num, T: fa_f32_f16](vec<N, T>) -> vec<N, T>
@must_use @const fn transpose[M: num, N: num, T: fa_f32_f16](mat<M, N, T>) -> mat<N, M, T>
@must_use @const fn trunc[T: fa_f32_f16](@test_value(1.5) T) -> T
@must_use @const fn trunc[N: num, T: fa_f32_f16](@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const fn unpack2x16float(u32) -> vec2<f32>
@must_use @const fn unpack2x16snorm(u32) -> vec2<f32>
@must_use @const fn unpack2x16unorm(u32) -> vec2<f32>
@must_use @const fn unpack4x8snorm(u32) -> vec4<f32>
@must_use @const fn unpack4x8unorm(u32) -> vec4<f32>
@must_use @const fn unpack4xI8(u32) -> vec4<i32>
@must_use @const fn unpack4xU8(u32) -> vec4<u32>
@stage("compute") fn workgroupBarrier()
@must_use @stage("compute") fn workgroupUniformLoad[T](ptr<workgroup, T, read_write>) -> T

@stage("compute") fn textureBarrier()
@must_use fn textureDimensions[T: fiu32](texture: texture_1d<T>) -> u32
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_1d<T>, level: L) -> u32
@must_use fn textureDimensions[T: fiu32](texture: texture_2d<T>) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_2d<T>, level: L) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32](texture: texture_2d_array<T>) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_2d_array<T>, level: L) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32](texture: texture_3d<T>) -> vec3<u32>
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_3d<T>, level: L) -> vec3<u32>
@must_use fn textureDimensions[T: fiu32](texture: texture_cube<T>) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_cube<T>, level: L) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32](texture: texture_cube_array<T>) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32, L: iu32](texture: texture_cube_array<T>, level: L) -> vec2<u32>
@must_use fn textureDimensions[T: fiu32](texture: texture_multisampled_2d<T>) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_2d) -> vec2<u32>
@must_use fn textureDimensions[L: iu32](texture: texture_depth_2d, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_2d_array) -> vec2<u32>
@must_use fn textureDimensions[L: iu32](texture: texture_depth_2d_array, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_cube) -> vec2<u32>
@must_use fn textureDimensions[L: iu32](texture: texture_depth_cube, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_cube_array) -> vec2<u32>
@must_use fn textureDimensions[L: iu32](texture: texture_depth_cube_array, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_multisampled_2d) -> vec2<u32>
@must_use fn textureDimensions[F: texel_format, R: read](texture: texture_storage_1d<F, R>) -> u32
@must_use fn textureDimensions[F: texel_format, R: read](texture: texture_storage_2d<F, R>) -> vec2<u32>
@must_use fn textureDimensions[F: texel_format, R: read](texture: texture_storage_2d_array<F, R>) -> vec2<u32>
@must_use fn textureDimensions[F: texel_format, R: read](texture: texture_storage_3d<F, R>) -> vec3<u32>
@must_use @stage("fragment", "compute") fn textureDimensions[F: texel_format, W: writable](texture: texture_storage_1d<F, W>) -> u32
@must_use @stage("fragment", "compute") fn textureDimensions[F: texel_format, W: writable](texture: texture_storage_2d<F, W>) -> vec2<u32>
@must_use @stage("fragment", "compute") fn textureDimensions[F: texel_format, W: writable](texture: texture_storage_2d_array<F, W>) -> vec2<u32>
@must_use @stage("fragment", "compute") fn textureDimensions[F: texel_format, W: writable](texture: texture_storage_3d<F, W>) -> vec3<u32>
@must_use fn textureDimensions(texture: texture_external) -> vec2<u32>
@must_use fn textureGather[T: fiu32, C: iu32](@const component: C, texture: texture_2d<T>, sampler: sampler, coords: vec2<f32>) -> vec4<T>
@must_use fn textureGather[T: fiu32, C: iu32](@const component: C, texture: texture_2d<T>, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<T>
@must_use fn textureGather[T: fiu32, C: iu32, A: iu32](@const component: C, texture: texture_2d_array<T>, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<T>
@must_use fn textureGather[T: fiu32, C: iu32, A: iu32](@const component: C, texture: texture_2d_array<T>, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<T>
@must_use fn textureGather[T: fiu32, C: iu32](@const component: C, texture: texture_cube<T>, sampler: sampler, coords: vec3<f32>) -> vec4<T>
@must_use fn textureGather[T: fiu32, C: iu32, A: iu32](@const component: C, texture: texture_cube_array<T>, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<T>
@must_use fn textureGather(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use fn textureGather(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGather[A: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>
@must_use fn textureGather[A: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGather(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use fn textureGather[A: iu32](texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGatherCompare[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> vec4<f32>
@must_use fn textureGatherCompare[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> vec4<f32>
@must_use fn textureGatherCompare[A: iu32](texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> vec4<f32>
@must_use fn textureNumLayers[T: fiu32](texture: texture_2d_array<T>) -> u32
@must_use fn textureNumLayers[T: fiu32](texture: texture_cube_array<T>) -> u32
@must_use fn textureNumLayers(texture: texture_depth_2d_array) -> u32
@must_use fn textureNumLayers(texture: texture_depth_cube_array) -> u32
@must_use fn textureNumLayers[F: texel_format, R: read](texture: texture_storage_2d_array<F, R>) -> u32
@must_use @stage("fragment", "compute") fn textureNumLayers[F: texel_format, W: writable](texture: texture_storage_2d_array<F, W>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_1d<T>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_2d<T>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_2d_array<T>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_3d<T>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_cube<T>) -> u32
@must_use fn textureNumLevels[T: fiu32](texture: texture_cube_array<T>) -> u32
@must_use fn textureNumLevels(texture: texture_depth_2d) -> u32
@must_use fn textureNumLevels(texture: texture_depth_2d_array) -> u32
@must_use fn textureNumLevels(texture: texture_depth_cube) -> u32
@must_use fn textureNumLevels(texture: texture_depth_cube_array) -> u32
@must_use fn textureNumSamples[T: fiu32](texture: texture_multisampled_2d<T>) -> u32
@must_use fn textureNumSamples(texture: texture_depth_multisampled_2d) -> u32
@must_use @stage("fragment") fn textureSample(texture: texture_1d<f32>, sampler: sampler, coords: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, @const offset: vec3<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>) -> f32
@must_use @stage("fragment") fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A) -> f32
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSample(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>) -> f32
@must_use @stage("fragment") fn textureSample[A: iu32](texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: A) -> f32
@must_use @stage("fragment") fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, bias: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32, @const offset: vec3<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias[A: iu32](texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSampleCompare[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> f32
@must_use @stage("fragment") fn textureSampleCompare[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
@must_use @stage("fragment") fn textureSampleCompare[A: iu32](texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use fn textureSampleCompareLevel[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel[A: iu32](texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel[A: iu32](texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> f32
@must_use fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleGrad[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
@must_use fn textureSampleGrad[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, ddx: vec2<f32>, ddy: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, @const offset: vec3<i32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use fn textureSampleGrad[A: iu32](texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleLevel[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel[A: iu32](texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, level: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32, @const offset: vec3<i32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel[A: iu32](texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel[L: iu32](texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: L) -> f32
@must_use fn textureSampleLevel[L: iu32](texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: L, @const offset: vec2<i32>) -> f32
@must_use fn textureSampleLevel[A: iu32, L: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, level: L) -> f32
@must_use fn textureSampleLevel[A: iu32, L: iu32](texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, level: L, @const offset: vec2<i32>) -> f32
@must_use fn textureSampleLevel[L: iu32](texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>, level: L) -> f32
@must_use fn textureSampleLevel[A: iu32, L: iu32](texture: texture_depth_cube_array,sampler: sampler, coords: vec3<f32>, array_index: A, level: L) -> f32
@must_use fn textureSampleBaseClampToEdge(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use fn textureSampleBaseClampToEdge(texture: texture_external, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@stage("fragment", "compute") fn textureStore[C: iu32, F: f32_texel_format, W: writable](texture: texture_storage_1d<F, W>, coords: C, value: vec4<f32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: f32_texel_format, W: writable](texture: texture_storage_2d<F, W>, coords: vec2<C>, value: vec4<f32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: f32_texel_format, W: writable, A: iu32](texture: texture_storage_2d_array<F, W>, coords: vec2<C>, array_index: A, value: vec4<f32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: f32_texel_format, W: writable](texture: texture_storage_3d<F, W>, coords: vec3<C>, value: vec4<f32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: i32_texel_format, W: writable](texture: texture_storage_1d<F, W>, coords: C, value: vec4<i32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: i32_texel_format, W: writable](texture: texture_storage_2d<F, W>, coords: vec2<C>, value: vec4<i32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: i32_texel_format, W: writable, A: iu32](texture: texture_storage_2d_array<F, W>, coords: vec2<C>, array_index: A, value: vec4<i32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: i32_texel_format, W: writable](texture: texture_storage_3d<F, W>, coords: vec3<C>, value: vec4<i32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: u32_texel_format, W: writable](texture: texture_storage_1d<F, W>, coords: C, value: vec4<u32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: u32_texel_format, W: writable](texture: texture_storage_2d<F, W>, coords: vec2<C>, value: vec4<u32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: u32_texel_format, W: writable, A: iu32](texture: texture_storage_2d_array<F, W>, coords: vec2<C>, array_index: A, value: vec4<u32>)
@stage("fragment", "compute") fn textureStore[C: iu32, F: u32_texel_format, W: writable](texture: texture_storage_3d<F, W>, coords: vec3<C>, value: vec4<u32>)
@must_use fn textureLoad[T: fiu32, C: iu32, L: iu32](texture: texture_1d<T>, coords: C, level: L) -> vec4<T>
@must_use fn textureLoad[T: fiu32, C: iu32, L: iu32](texture: texture_2d<T>, coords: vec2<C>, level: L) -> vec4<T>
@must_use fn textureLoad[T: fiu32, C: iu32, A: iu32, L: iu32](texture: texture_2d_array<T>, coords: vec2<C>, array_index: A, level: L) -> vec4<T>
@must_use fn textureLoad[T: fiu32, C: iu32, L: iu32](texture: texture_3d<T>, coords: vec3<C>, level: L) -> vec4<T>
@must_use fn textureLoad[T: fiu32, C: iu32, S: iu32](texture: texture_multisampled_2d<T>, coords: vec2<C>, sample_index: S) -> vec4<T>
@must_use fn textureLoad[C: iu32, L: iu32](texture: texture_depth_2d, coords: vec2<C>, level: L) -> f32
@must_use fn textureLoad[C: iu32, A: iu32, L: iu32](texture: texture_depth_2d_array, coords: vec2<C>, array_index: A, level: L) -> f32
@must_use fn textureLoad[C: iu32, S: iu32](texture: texture_depth_multisampled_2d, coords: vec2<C>, sample_index: S) -> f32
@must_use fn textureLoad[C: iu32](texture: texture_external, coords: vec2<C>) -> vec4<f32>
@must_use fn textureLoad[C: iu32, F: f32_texel_format, R: read](texture: texture_storage_1d<F, R>, coords: C) -> vec4<f32>
@must_use fn textureLoad[C: iu32, F: i32_texel_format, R: read](texture: texture_storage_1d<F, R>, coords: C) -> vec4<i32>
@must_use fn textureLoad[C: iu32, F: u32_texel_format, R: read](texture: texture_storage_1d<F, R>, coords: C) -> vec4<u32>
@must_use fn textureLoad[C: iu32, F: f32_texel_format, R: read](texture: texture_storage_2d<F, R>, coords: vec2<C>) -> vec4<f32>
@must_use fn textureLoad[C: iu32, F: i32_texel_format, R: read](texture: texture_storage_2d<F, R>, coords: vec2<C>) -> vec4<i32>
@must_use fn textureLoad[C: iu32, F: u32_texel_format, R: read](texture: texture_storage_2d<F, R>, coords: vec2<C>) -> vec4<u32>
@must_use fn textureLoad[C: iu32, F: f32_texel_format, R: read, A: iu32](texture: texture_storage_2d_array<F, R>, coords: vec2<C>, array_index: A) -> vec4<f32>
@must_use fn textureLoad[C: iu32, F: i32_texel_format, R: read, A: iu32](texture: texture_storage_2d_array<F, R>, coords: vec2<C>, array_index: A) -> vec4<i32>
@must_use fn textureLoad[C: iu32, F: u32_texel_format, R: read, A: iu32](texture: texture_storage_2d_array<F, R>, coords: vec2<C>, array_index: A) -> vec4<u32>
@must_use fn textureLoad[C: iu32, F: f32_texel_format, R: read](texture: texture_storage_3d<F, R>, coords: vec3<C>) -> vec4<f32>
@must_use fn textureLoad[C: iu32, F: i32_texel_format, R: read](texture: texture_storage_3d<F, R>, coords: vec3<C>) -> vec4<i32>
@must_use fn textureLoad[C: iu32, F: u32_texel_format, R: read](texture: texture_storage_3d<F, R>, coords: vec3<C>) -> vec4<u32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: f32_texel_format, RW: read_write](texture: texture_storage_1d<F, RW>, coords: C) -> vec4<f32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: i32_texel_format, RW: read_write](texture: texture_storage_1d<F, RW>, coords: C) -> vec4<i32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: u32_texel_format, RW: read_write](texture: texture_storage_1d<F, RW>, coords: C) -> vec4<u32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: f32_texel_format, RW: read_write](texture: texture_storage_2d<F, RW>, coords: vec2<C>) -> vec4<f32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: i32_texel_format, RW: read_write](texture: texture_storage_2d<F, RW>, coords: vec2<C>) -> vec4<i32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: u32_texel_format, RW: read_write](texture: texture_storage_2d<F, RW>, coords: vec2<C>) -> vec4<u32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: f32_texel_format, RW: read_write, A: iu32](texture: texture_storage_2d_array<F, RW>, coords: vec2<C>, array_index: A) -> vec4<f32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: i32_texel_format, RW: read_write, A: iu32](texture: texture_storage_2d_array<F, RW>, coords: vec2<C>, array_index: A) -> vec4<i32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: u32_texel_format, RW: read_write, A: iu32](texture: texture_storage_2d_array<F, RW>, coords: vec2<C>, array_index: A) -> vec4<u32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: f32_texel_format, RW: read_write](texture: texture_storage_3d<F, RW>, coords: vec3<C>) -> vec4<f32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: i32_texel_format, RW: read_write](texture: texture_storage_3d<F, RW>, coords: vec3<C>) -> vec4<i32>
@must_use @stage("fragment", "compute") fn textureLoad[C: iu32, F: u32_texel_format, RW: read_write](texture: texture_storage_3d<F, RW>, coords: vec3<C>) -> vec4<u32>

@stage("fragment") fn inputAttachmentLoad[T: fiu32](input_attachment: input_attachment<T>) -> vec4<T>

@stage("fragment", "compute") fn atomicLoad[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>) -> T
@stage("fragment", "compute") fn atomicStore[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T)
@stage("fragment", "compute") fn atomicAdd[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicSub[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicMax[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicMin[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicAnd[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicOr[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicXor[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicExchange[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") fn atomicCompareExchangeWeak[T: iu32, S: workgroup_or_storage](ptr<S, atomic<T>, read_write>, T, T) -> __atomic_compare_exchange_result<T>

@must_use @stage("compute") fn subgroupBallot(bool) -> vec4<u32>
@must_use @stage("compute") fn subgroupBroadcast[T: fiu32_f16](value: T, @const sourceLaneIndex: u32) -> T
@must_use @stage("compute") fn subgroupBroadcast[N: num, T: fiu32_f16](value: vec<N, T>, @const sourceLaneIndex: u32) -> vec<N, T>

////////////////////////////////////////////////////////////////////////////////
// Value constructors                                                         //
////////////////////////////////////////////////////////////////////////////////

// Zero value constructors
@must_use @const("Zero") ctor i32() -> i32
@must_use @const("Zero") ctor u32() -> u32
@must_use @const("Zero") ctor f32() -> f32
@must_use @const("Zero") ctor f16() -> f16
@must_use @const("Zero") ctor bool() -> bool
@must_use @const("Zero") ctor vec2() -> vec2<ia>
@must_use @const("Zero") ctor vec3() -> vec3<ia>
@must_use @const("Zero") ctor vec4() -> vec4<ia>
@must_use @const("Zero") ctor vec2<T: concrete_scalar>() -> vec2<T>
@must_use @const("Zero") ctor vec3<T: concrete_scalar>() -> vec3<T>
@must_use @const("Zero") ctor vec4<T: concrete_scalar>() -> vec4<T>
@must_use @const("Zero") ctor mat2x2<T: f32_f16>() -> mat2x2<T>
@must_use @const("Zero") ctor mat2x3<T: f32_f16>() -> mat2x3<T>
@must_use @const("Zero") ctor mat2x4<T: f32_f16>() -> mat2x4<T>
@must_use @const("Zero") ctor mat3x2<T: f32_f16>() -> mat3x2<T>
@must_use @const("Zero") ctor mat3x3<T: f32_f16>() -> mat3x3<T>
@must_use @const("Zero") ctor mat3x4<T: f32_f16>() -> mat3x4<T>
@must_use @const("Zero") ctor mat4x2<T: f32_f16>() -> mat4x2<T>
@must_use @const("Zero") ctor mat4x3<T: f32_f16>() -> mat4x3<T>
@must_use @const("Zero") ctor mat4x4<T: f32_f16>() -> mat4x4<T>

// Identity constructors
@must_use @const("Identity") ctor i32(i32) -> i32
@must_use @const("Identity") ctor u32(u32) -> u32
@must_use @const("Identity") ctor f32(f32) -> f32
@must_use @const("Identity") ctor f16(f16) -> f16
@must_use @const("Identity") ctor bool(bool) -> bool
@must_use @const("Identity") ctor vec2<T: concrete_scalar>(vec2<T>) -> vec2<T>
@must_use @const("Identity") ctor vec2[T: scalar](vec2<T>) -> vec2<T>
@must_use @const("Identity") ctor vec3<T: concrete_scalar>(vec3<T>) -> vec3<T>
@must_use @const("Identity") ctor vec3[T: scalar](vec3<T>) -> vec3<T>
@must_use @const("Identity") ctor vec4<T: concrete_scalar>(vec4<T>) -> vec4<T>
@must_use @const("Identity") ctor vec4[T: scalar](vec4<T>) -> vec4<T>
@must_use @const("Identity") ctor mat2x2<T: f32_f16>(mat2x2<T>) -> mat2x2<T>
@must_use @const("Identity") ctor mat2x2[T: fa_f32_f16](mat2x2<T>) -> mat2x2<T>
@must_use @const("Identity") ctor mat2x3<T: f32_f16>(mat2x3<T>) -> mat2x3<T>
@must_use @const("Identity") ctor mat2x3[T: fa_f32_f16](mat2x3<T>) -> mat2x3<T>
@must_use @const("Identity") ctor mat2x4<T: f32_f16>(mat2x4<T>) -> mat2x4<T>
@must_use @const("Identity") ctor mat2x4[T: fa_f32_f16](mat2x4<T>) -> mat2x4<T>
@must_use @const("Identity") ctor mat3x2<T: f32_f16>(mat3x2<T>) -> mat3x2<T>
@must_use @const("Identity") ctor mat3x2[T: fa_f32_f16](mat3x2<T>) -> mat3x2<T>
@must_use @const("Identity") ctor mat3x3<T: f32_f16>(mat3x3<T>) -> mat3x3<T>
@must_use @const("Identity") ctor mat3x3[T: fa_f32_f16](mat3x3<T>) -> mat3x3<T>
@must_use @const("Identity") ctor mat3x4<T: f32_f16>(mat3x4<T>) -> mat3x4<T>
@must_use @const("Identity") ctor mat3x4[T: fa_f32_f16](mat3x4<T>) -> mat3x4<T>
@must_use @const("Identity") ctor mat4x2<T: f32_f16>(mat4x2<T>) -> mat4x2<T>
@must_use @const("Identity") ctor mat4x2[T: fa_f32_f16](mat4x2<T>) -> mat4x2<T>
@must_use @const("Identity") ctor mat4x3<T: f32_f16>(mat4x3<T>) -> mat4x3<T>
@must_use @const("Identity") ctor mat4x3[T: fa_f32_f16](mat4x3<T>) -> mat4x3<T>
@must_use @const("Identity") ctor mat4x4<T: f32_f16>(mat4x4<T>) -> mat4x4<T>
@must_use @const("Identity") ctor mat4x4[T: fa_f32_f16](mat4x4<T>) -> mat4x4<T>

// Vector constructors (splat)
@must_use @const("VecSplat") ctor vec2<T: concrete_scalar>(T) -> vec2<T>
@must_use @const("VecSplat") ctor vec2[T: scalar](T) -> vec2<T>
@must_use @const("VecSplat") ctor vec3<T: concrete_scalar>(T) -> vec3<T>
@must_use @const("VecSplat") ctor vec3[T: scalar](T) -> vec3<T>
@must_use @const("VecSplat") ctor vec4<T: concrete_scalar>(T) -> vec4<T>
@must_use @const("VecSplat") ctor vec4[T: scalar](T) -> vec4<T>

// Vector constructors (scalar)
@must_use @const("VecInitS") ctor vec2<T: concrete_scalar>(x: T, y: T) -> vec2<T>
@must_use @const("VecInitS") ctor vec2[T: scalar](x: T, y: T) -> vec2<T>
@must_use @const("VecInitS") ctor vec3<T: concrete_scalar>(x: T, y: T, z: T) -> vec3<T>
@must_use @const("VecInitS") ctor vec3[T: scalar](x: T, y: T, z: T) -> vec3<T>
@must_use @const("VecInitS") ctor vec4<T: concrete_scalar>(x: T, y: T, z: T, w: T) -> vec4<T>
@must_use @const("VecInitS") ctor vec4[T: scalar](x: T, y: T, z: T, w: T) -> vec4<T>

// Vector constructors (mixed)
@must_use @const("VecInitM") ctor vec3<T: concrete_scalar>(xy: vec2<T>, z: T) -> vec3<T>
@must_use @const("VecInitM") ctor vec3[T: scalar](xy: vec2<T>, z: T) -> vec3<T>
@must_use @const("VecInitM") ctor vec3<T: concrete_scalar>(x: T, yz: vec2<T>) -> vec3<T>
@must_use @const("VecInitM") ctor vec3[T: scalar](x: T, yz: vec2<T>) -> vec3<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(xy: vec2<T>, z: T, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](xy: vec2<T>, z: T, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(x: T, yz: vec2<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](x: T, yz: vec2<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(x: T, y: T, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](x: T, y: T, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(xy: vec2<T>, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](xy: vec2<T>, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(xyz: vec3<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](xyz: vec3<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: concrete_scalar>(x: T, zyw: vec3<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4[T: scalar](x: T, zyw: vec3<T>) -> vec4<T>

// Matrix constructors (scalar)
@must_use @const("MatInitS")
ctor mat2x2<T: fa_f32_f16>(T, T,
                           T, T) -> mat2x2<T>
@must_use @const("MatInitS")
ctor mat2x2[T: fa_f32_f16](T, T,
                           T, T) -> mat2x2<T>

@must_use @const("MatInitS")
ctor mat2x3<T: fa_f32_f16>(T, T, T,
                           T, T, T) -> mat2x3<T>
@must_use @const("MatInitS")
ctor mat2x3[T: fa_f32_f16](T, T, T,
                           T, T, T) -> mat2x3<T>

@must_use @const("MatInitS")
ctor mat2x4<T: fa_f32_f16>(T, T, T, T,
                           T, T, T, T) -> mat2x4<T>
@must_use @const("MatInitS")
ctor mat2x4[T: fa_f32_f16](T, T, T, T,
                           T, T, T, T) -> mat2x4<T>

@must_use @const("MatInitS")
ctor mat3x2<T: fa_f32_f16>(T, T,
                           T, T,
                           T, T) -> mat3x2<T>
@must_use @const("MatInitS")
ctor mat3x2[T: fa_f32_f16](T, T,
                           T, T,
                           T, T) -> mat3x2<T>

@must_use @const("MatInitS")
ctor mat3x3<T: fa_f32_f16>(T, T, T,
                           T, T, T,
                           T, T, T) -> mat3x3<T>
@must_use @const("MatInitS")
ctor mat3x3[T: fa_f32_f16](T, T, T,
                           T, T, T,
                           T, T, T) -> mat3x3<T>

@must_use @const("MatInitS")
ctor mat3x4<T: fa_f32_f16>(T, T, T, T,
                           T, T, T, T,
                           T, T, T, T) -> mat3x4<T>
@must_use @const("MatInitS")
ctor mat3x4[T: fa_f32_f16](T, T, T, T,
                           T, T, T, T,
                           T, T, T, T) -> mat3x4<T>

@must_use @const("MatInitS")
ctor mat4x2<T: fa_f32_f16>(T, T,
                           T, T,
                           T, T,
                           T, T) -> mat4x2<T>
@must_use @const("MatInitS")
ctor mat4x2[T: fa_f32_f16](T, T,
                           T, T,
                           T, T,
                           T, T) -> mat4x2<T>

@must_use @const("MatInitS")
ctor mat4x3<T: fa_f32_f16>(T, T, T,
                           T, T, T,
                           T, T, T,
                           T, T, T) -> mat4x3<T>
@must_use @const("MatInitS")
ctor mat4x3[T: fa_f32_f16](T, T, T,
                           T, T, T,
                           T, T, T,
                           T, T, T) -> mat4x3<T>

@must_use @const("MatInitS")
ctor mat4x4<T: fa_f32_f16>(T, T, T, T,
                           T, T, T, T,
                           T, T, T, T,
                           T, T, T, T) -> mat4x4<T>
@must_use @const("MatInitS")
ctor mat4x4[T: fa_f32_f16](T, T, T, T,
                           T, T, T, T,
                           T, T, T, T,
                           T, T, T, T) -> mat4x4<T>

// Matrix constructors (column vectors)
@must_use @const("MatInitV") ctor mat2x2<T: fa_f32_f16>(vec2<T>, vec2<T>) -> mat2x2<T>
@must_use @const("MatInitV") ctor mat2x2[T: fa_f32_f16](vec2<T>, vec2<T>) -> mat2x2<T>
@must_use @const("MatInitV") ctor mat2x3<T: fa_f32_f16>(vec3<T>, vec3<T>) -> mat2x3<T>
@must_use @const("MatInitV") ctor mat2x3[T: fa_f32_f16](vec3<T>, vec3<T>) -> mat2x3<T>
@must_use @const("MatInitV") ctor mat2x4<T: fa_f32_f16>(vec4<T>, vec4<T>) -> mat2x4<T>
@must_use @const("MatInitV") ctor mat2x4[T: fa_f32_f16](vec4<T>, vec4<T>) -> mat2x4<T>
@must_use @const("MatInitV") ctor mat3x2<T: fa_f32_f16>(vec2<T>, vec2<T>, vec2<T>) -> mat3x2<T>
@must_use @const("MatInitV") ctor mat3x2[T: fa_f32_f16](vec2<T>, vec2<T>, vec2<T>) -> mat3x2<T>
@must_use @const("MatInitV") ctor mat3x3<T: fa_f32_f16>(vec3<T>, vec3<T>, vec3<T>) -> mat3x3<T>
@must_use @const("MatInitV") ctor mat3x3[T: fa_f32_f16](vec3<T>, vec3<T>, vec3<T>) -> mat3x3<T>
@must_use @const("MatInitV") ctor mat3x4<T: fa_f32_f16>(vec4<T>, vec4<T>, vec4<T>) -> mat3x4<T>
@must_use @const("MatInitV") ctor mat3x4[T: fa_f32_f16](vec4<T>, vec4<T>, vec4<T>) -> mat3x4<T>
@must_use @const("MatInitV") ctor mat4x2<T: fa_f32_f16>(vec2<T>, vec2<T>, vec2<T>, vec2<T>) -> mat4x2<T>
@must_use @const("MatInitV") ctor mat4x2[T: fa_f32_f16](vec2<T>, vec2<T>, vec2<T>, vec2<T>) -> mat4x2<T>
@must_use @const("MatInitV") ctor mat4x3<T: fa_f32_f16>(vec3<T>, vec3<T>, vec3<T>, vec3<T>) -> mat4x3<T>
@must_use @const("MatInitV") ctor mat4x3[T: fa_f32_f16](vec3<T>, vec3<T>, vec3<T>, vec3<T>) -> mat4x3<T>
@must_use @const("MatInitV") ctor mat4x4<T: fa_f32_f16>(vec4<T>, vec4<T>, vec4<T>, vec4<T>) -> mat4x4<T>
@must_use @const("MatInitV") ctor mat4x4[T: fa_f32_f16](vec4<T>, vec4<T>, vec4<T>, vec4<T>) -> mat4x4<T>

////////////////////////////////////////////////////////////////////////////////
// Value conversions                                                          //
////////////////////////////////////////////////////////////////////////////////
@must_use @const conv f32[T: scalar_no_f32](T) -> f32
@must_use @const conv f16[T: scalar_no_f16](T) -> f16
@must_use @const conv i32[T: scalar_no_i32](T) -> i32
@must_use @const conv u32[T: scalar_no_u32](T) -> u32
@must_use @const conv bool[T: scalar_no_bool](T) -> bool

@must_use @const conv vec2<T: f32>[U: scalar_no_f32](vec2<U>) -> vec2<T>
@must_use @const conv vec2<T: f16>[U: scalar_no_f16](vec2<U>) -> vec2<T>
@must_use @const conv vec2<T: i32>[U: scalar_no_i32](vec2<U>) -> vec2<T>
@must_use @const conv vec2<T: u32>[U: scalar_no_u32](vec2<U>) -> vec2<T>
@must_use @const conv vec2<T: bool>[U: scalar_no_bool](vec2<U>) -> vec2<T>

@must_use @const conv vec3<T: f32>[U: scalar_no_f32](vec3<U>) -> vec3<T>
@must_use @const conv vec3<T: f16>[U: scalar_no_f16](vec3<U>) -> vec3<T>
@must_use @const conv vec3<T: i32>[U: scalar_no_i32](vec3<U>) -> vec3<T>
@must_use @const conv vec3<T: u32>[U: scalar_no_u32](vec3<U>) -> vec3<T>
@must_use @const conv vec3<T: bool>[U: scalar_no_bool](vec3<U>) -> vec3<T>

@must_use @const conv vec4<T: f32>[U: scalar_no_f32](vec4<U>) -> vec4<T>
@must_use @const conv vec4<T: f16>[U: scalar_no_f16](vec4<U>) -> vec4<T>
@must_use @const conv vec4<T: i32>[U: scalar_no_i32](vec4<U>) -> vec4<T>
@must_use @const conv vec4<T: u32>[U: scalar_no_u32](vec4<U>) -> vec4<T>
@must_use @const conv vec4<T: bool>[U: scalar_no_bool](vec4<U>) -> vec4<T>

@must_use @const conv mat2x2<T: f16>(mat2x2<f32>) -> mat2x2<T>
@must_use @const conv mat2x2<T: f32>(mat2x2<f16>) -> mat2x2<T>
@must_use @const conv mat2x3<T: f16>(mat2x3<f32>) -> mat2x3<T>
@must_use @const conv mat2x3<T: f32>(mat2x3<f16>) -> mat2x3<T>
@must_use @const conv mat2x4<T: f16>(mat2x4<f32>) -> mat2x4<T>
@must_use @const conv mat2x4<T: f32>(mat2x4<f16>) -> mat2x4<T>
@must_use @const conv mat3x2<T: f16>(mat3x2<f32>) -> mat3x2<T>
@must_use @const conv mat3x2<T: f32>(mat3x2<f16>) -> mat3x2<T>
@must_use @const conv mat3x3<T: f16>(mat3x3<f32>) -> mat3x3<T>
@must_use @const conv mat3x3<T: f32>(mat3x3<f16>) -> mat3x3<T>
@must_use @const conv mat3x4<T: f16>(mat3x4<f32>) -> mat3x4<T>
@must_use @const conv mat3x4<T: f32>(mat3x4<f16>) -> mat3x4<T>
@must_use @const conv mat4x2<T: f16>(mat4x2<f32>) -> mat4x2<T>
@must_use @const conv mat4x2<T: f32>(mat4x2<f16>) -> mat4x2<T>
@must_use @const conv mat4x3<T: f16>(mat4x3<f32>) -> mat4x3<T>
@must_use @const conv mat4x3<T: f32>(mat4x3<f16>) -> mat4x3<T>
@must_use @const conv mat4x4<T: f16>(mat4x4<f32>) -> mat4x4<T>
@must_use @const conv mat4x4<T: f32>(mat4x4<f16>) -> mat4x4<T>

// Conversion from vec3 to internal __packed_vec3 type.
@must_use @const conv packedVec3<T: concrete_scalar>(vec3<T>) -> packedVec3<T>
@must_use @const conv packedVec3[T: concrete_scalar](vec3<T>) -> packedVec3<T>

////////////////////////////////////////////////////////////////////////////////
// Unary Operators                                                            //
////////////////////////////////////////////////////////////////////////////////
@must_use op & [S: address_space, T, A: access] (ref<S, T, A>) -> ptr<S, T, A>
@must_use op * [S: address_space, T, A: access] (ptr<S, T, A>) -> ref<S, T, A>

@must_use @const op ! (bool) -> bool
@must_use @const op ! [N: num](vec<N, bool>) -> vec<N, bool>

@must_use @const op ~ [T: ia_iu32](T) -> T
@must_use @const op ~ [T: ia_iu32, N: num](vec<N, T>) -> vec<N, T>

@must_use @const("UnaryMinus") op - [T: fia_fi32_f16](T) -> T
@must_use @const("UnaryMinus") op - [T: fia_fi32_f16, N: num](vec<N, T>) -> vec<N, T>

////////////////////////////////////////////////////////////////////////////////
// Binary Operators                                                           //
////////////////////////////////////////////////////////////////////////////////
@must_use @const op + [T: fia_fiu32_f16](T, T) -> T
@must_use @const op + [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const op + [T: fia_fiu32_f16, N: num](vec<N, T>, T) -> vec<N, T>
@must_use @const op + [T: fia_fiu32_f16, N: num](T, vec<N, T>) -> vec<N, T>
@must_use @const op + [T: fa_f32_f16, N: num, M: num](mat<N, M, T>, mat<N, M, T>) -> mat<N, M, T>

@must_use @const op - [T: fia_fiu32_f16](T, T) -> T
@must_use @const op - [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const op - [T: fia_fiu32_f16, N: num](vec<N, T>, T) -> vec<N, T>
@must_use @const op - [T: fia_fiu32_f16, N: num](T, vec<N, T>) -> vec<N, T>
@must_use @const op - [T: fa_f32_f16, N: num, M: num](mat<N, M, T>, mat<N, M, T>) -> mat<N, M, T>

@must_use @const("Multiply") op * [T: fia_fiu32_f16](T, T) -> T
@must_use @const("Multiply") op * [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const("Multiply") op * [T: fia_fiu32_f16, N: num](vec<N, T>, T) -> vec<N, T>
@must_use @const("Multiply") op * [T: fia_fiu32_f16, N: num](T, vec<N, T>) -> vec<N, T>
@must_use @const("Multiply") op * [T: fa_f32_f16, N: num, M: num](T, mat<N, M, T>) -> mat<N, M, T>
@must_use @const("Multiply") op * [T: fa_f32_f16, N: num, M: num](mat<N, M, T>, T) -> mat<N, M, T>
@must_use @const("MultiplyMatVec") op * [T: fa_f32_f16, C: num, R: num](mat<C, R, T>, vec<C, T>) -> vec<R, T>
@must_use @const("MultiplyVecMat") op * [T: fa_f32_f16, C: num, R: num](vec<R, T>, mat<C, R, T>) -> vec<C, T>
@must_use @const("MultiplyMatMat") op * [T: fa_f32_f16, K: num, C: num, R: num](mat<K, R, T>, mat<C, K, T>) -> mat<C, R, T>

@must_use @const op / [T: fia_fiu32_f16](T, T) -> T
@must_use @const op / [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const op / [T: fia_fiu32_f16, N: num](vec<N, T>, T) -> vec<N, T>
@must_use @const op / [T: fia_fiu32_f16, N: num](T, vec<N, T>) -> vec<N, T>

@must_use @const op % [T: fia_fiu32_f16](T, T) -> T
@must_use @const op % [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const op % [T: fia_fiu32_f16, N: num](vec<N, T>, T) -> vec<N, T>
@must_use @const op % [T: fia_fiu32_f16, N: num](T, vec<N, T>) -> vec<N, T>

@must_use @const op ^ [T: ia_iu32](T, T) -> T
@must_use @const op ^ [T: ia_iu32, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op & (bool, bool) -> bool
@must_use @const op & [N: num](vec<N, bool>, vec<N, bool>) -> vec<N, bool>
@must_use @const op & [T: ia_iu32](T, T) -> T
@must_use @const op & [T: ia_iu32, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op | (bool, bool) -> bool
@must_use @const op | [N: num](vec<N, bool>, vec<N, bool>) -> vec<N, bool>
@must_use @const op | [T: ia_iu32](T, T) -> T
@must_use @const op | [T: ia_iu32, N: num](vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op && (bool, bool) -> bool
@must_use @const op || (bool, bool) -> bool

@must_use @const op == [T: scalar](T, T) -> bool
@must_use @const op == [T: scalar, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op != [T: scalar](T, T) -> bool
@must_use @const op != [T: scalar, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op < [T: fia_fiu32_f16](T, T) -> bool
@must_use @const op < [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op > [T: fia_fiu32_f16](T, T) -> bool
@must_use @const op > [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op <= [T: fia_fiu32_f16](T, T) -> bool
@must_use @const op <= [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op >= [T: fia_fiu32_f16](T, T) -> bool
@must_use @const op >= [T: fia_fiu32_f16, N: num](vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const op << [T: ia_iu32](T, u32) -> T
@must_use @const op << [T: ia_iu32, N: num](vec<N, T>, vec<N, u32>) -> vec<N, T>

@must_use @const op >> [T: ia_iu32](T, u32) -> T
@must_use @const op >> [T: ia_iu32, N: num](vec<N, T>, vec<N, u32>) -> vec<N, T>

////////////////////////////////////////////////////////////////////////////////
// Tint internal builtins                                                     //
////////////////////////////////////////////////////////////////////////////////
@const("Identity") fn __tint_materialize[T](T) -> T
