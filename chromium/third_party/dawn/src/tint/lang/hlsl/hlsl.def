// Copyright 2024 The Dawn & Tint Authors
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////////////////
// HLSL builtin definition file                                               //
//                                                                            //
// After modifying this file, run:                                            //
//    tools/run gen                                                           //
// from the Dawn source directory.                                            //
//                                                                            //
// See docs/tint/intrinsic_definition_files.md for syntax                     //
////////////////////////////////////////////////////////////////////////////////

import "src/tint/lang/core/address_space.def"
import "src/tint/lang/core/access.def"
import "src/tint/lang/core/texel_format.def"

////////////////////////////////////////////////////////////////////////////////
// Types                                                                      //
////////////////////////////////////////////////////////////////////////////////

type i32
type u32
type f32
type f16
type ptr<S: address_space, T, A: access>
type vec2<T>
type vec3<T>
type vec4<T>
@display("vec{N}<{T}>")     type vec<N: num, T>
type mat2x2<T>
type mat2x3<T>
type mat2x4<T>
type mat3x2<T>
type mat3x3<T>
type mat3x4<T>
type mat4x2<T>
type mat4x3<T>
type mat4x4<T>
@display("mat{N}x{M}<{T}>") type mat<N: num, M: num, T>
type atomic<T>

type byte_address_buffer<A: access>
type int8_t4_packed
type uint8_t4_packed

type sampler
type sampler_comparison
type texture_1d<T>
type texture_2d<T>
type texture_2d_array<T>
type texture_3d<T>
type texture_cube<T>
type texture_cube_array<T>
type texture_depth_2d
type texture_depth_2d_array
type texture_depth_cube
type texture_depth_cube_array
type texture_depth_multisampled_2d
type texture_multisampled_2d<T>
type texture_storage_1d<F: texel_format, A: access>
type texture_storage_2d<F: texel_format, A: access>
type texture_storage_2d_array<F: texel_format, A: access>
type texture_storage_3d<F: texel_format, A: access>

////////////////////////////////////////////////////////////////////////////////
// Type matchers                                                              //
////////////////////////////////////////////////////////////////////////////////

match iu32: i32 | u32
match fiu32: f32 | i32 | u32
match f32_u32: f32 | u32
match f32_i32: f32 | i32
match f32_f16: f32 | f16
match fi32_f16: f32 | i32 | f16

match storage: address_space.storage
match function: address_space.function
match workgroup: address_space.workgroup

match read_write: access.read_write
match readable
  : access.read
  | access.read_write
match writable
  : access.write
  | access.read_write

match f32_texel_format
  : texel_format.r8unorm
  | texel_format.bgra8unorm
  | texel_format.rgba8unorm
  | texel_format.rgba8snorm
  | texel_format.rgba16float
  | texel_format.r32float
  | texel_format.rg32float
  | texel_format.rgba32float

match u32_texel_format
  : texel_format.rgba8uint
  | texel_format.rgba16uint
  | texel_format.r32uint
  | texel_format.rg32uint
  | texel_format.rgba32uint

match i32_texel_format
  : texel_format.rgba8sint
  | texel_format.rgba16sint
  | texel_format.r32sint
  | texel_format.rg32sint
  | texel_format.rgba32sint

////////////////////////////////////////////////////////////////////////////////
// Builtin Functions                                                          //
////////////////////////////////////////////////////////////////////////////////

fn asint[T: f32_u32](T) -> i32
fn asint[T: f32_u32, N: num](vec<N, T>) -> vec<N, i32>

fn asuint[T: f32_i32](T) -> u32
fn asuint[T: f32_i32, N: num](vec<N, T>) -> vec<N, u32>

fn asfloat[T: iu32](T) -> f32
fn asfloat[T: iu32, N: num](vec<N, T>) -> vec<N, f32>

fn dot4add_i8packed(u32, u32, ptr<function, i32, writable>) -> i32
fn dot4add_u8packed(u32, u32, ptr<function, u32, writable>) -> u32

fn f32tof16(f32) -> u32
fn f32tof16[N: num](vec<N, f32>) -> vec<N, u32>

fn f16tof32(u32) -> f32
fn f16tof32[N: num](vec<N, u32>) -> vec<N, f32>

fn InterlockedCompareExchange[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                                compare_value: iu32,
                                        value: iu32,
                               original_value: ptr<function, iu32, read_write>)
fn InterlockedExchange[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                                 value: iu32,
                        original_value: ptr<function, iu32, read_write>)
fn InterlockedAdd[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                            value: iu32,
                   original_value: ptr<function, iu32, read_write>)
fn InterlockedMax[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                            value: iu32,
                   original_value: ptr<function, iu32, read_write>)
fn InterlockedMin[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                            value: iu32,
                   original_value: ptr<function, iu32, read_write>)
fn InterlockedAnd[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                            value: iu32,
                   original_value: ptr<function, iu32, read_write>)
fn InterlockedOr[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                           value: iu32,
                  original_value: ptr<function, iu32, read_write>)
fn InterlockedXor[T: iu32](ptr<workgroup, atomic<T>, read_write>,
                            value: iu32,
                   original_value: ptr<function, iu32, read_write>)

// Treat the HLSL matrices as transposed when used in `mul`
fn mul [T: f32_f16, C: num, R: num](mat<R, C, T>, vec<C, T>) -> vec<R, T>
fn mul [T: f32_f16, C: num, R: num](vec<R, T>, mat<R, C, T>) -> vec<C, T>
fn mul [T: f32_f16, K: num, C: num, R: num](mat<R, K, T>, mat<K, C, T>) -> mat<R, C, T>

fn pack_u8(vec4<u32>) -> uint8_t4_packed
fn pack_s8(vec4<i32>) -> int8_t4_packed
fn pack_clamp_s8(vec4<i32>) -> int8_t4_packed

fn sign[T: fi32_f16](T) -> i32
fn sign[N: num, T: fi32_f16](vec<N, T>) -> vec<N, i32>

fn textureStore[C: iu32](texture: texture_storage_1d<f32_texel_format, writable>,
                          coords: C,
                           value: vec4<f32>)
fn textureStore[C: iu32](texture: texture_storage_2d<f32_texel_format, writable>,
                          coords: vec2<C>,
                           value: vec4<f32>)
fn textureStore[C: iu32](texture: texture_storage_2d_array<f32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<f32>)
fn textureStore[C: iu32](texture: texture_storage_3d<f32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<f32>)
fn textureStore[C: iu32](texture: texture_storage_1d<i32_texel_format, writable>,
                          coords: C,
                           value: vec4<i32>)
fn textureStore[C: iu32](texture: texture_storage_2d<i32_texel_format, writable>,
                          coords: vec2<C>,
                           value: vec4<i32>)
fn textureStore[C: iu32](texture: texture_storage_2d_array<i32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<i32>)
fn textureStore[C: iu32](texture: texture_storage_3d<i32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<i32>)
fn textureStore[C: iu32](texture: texture_storage_1d<u32_texel_format, writable>,
                          coords: C,
                           value: vec4<u32>)
fn textureStore[C: iu32](texture: texture_storage_2d<u32_texel_format, writable>,
                          coords: vec2<C>,
                           value: vec4<u32>)
fn textureStore[C: iu32](texture: texture_storage_2d_array<u32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<u32>)
fn textureStore[C: iu32](texture: texture_storage_3d<u32_texel_format, writable>,
                          coords: vec3<C>,
                           value: vec4<u32>)

fn unpack_s8s32(int8_t4_packed) -> vec4<i32>
fn unpack_u8u32(uint8_t4_packed) -> vec4<u32>


////////////////////////////////////////////////////////////////////////////////
// Member Functions                                                           //
////////////////////////////////////////////////////////////////////////////////

@member_function fn Load(byte_address_buffer<readable>, offset: u32) -> u32
@member_function fn Load2(byte_address_buffer<readable>, offset: u32) -> vec2<u32>
@member_function fn Load3(byte_address_buffer<readable>, offset: u32) -> vec3<u32>
@member_function fn Load4(byte_address_buffer<readable>, offset: u32) -> vec4<u32>

@member_function fn LoadF16(byte_address_buffer<readable>, offset: u32) -> f16
@member_function fn Load2F16(byte_address_buffer<readable>, offset: u32) -> vec2<f16>
@member_function fn Load3F16(byte_address_buffer<readable>, offset: u32) -> vec3<f16>
@member_function fn Load4F16(byte_address_buffer<readable>, offset: u32) -> vec4<f16>

@member_function fn Store(byte_address_buffer<writable>, offset: u32, value: u32)
@member_function fn Store2(byte_address_buffer<writable>, offset: u32, value: vec2<u32>)
@member_function fn Store3(byte_address_buffer<writable>, offset: u32, value: vec3<u32>)
@member_function fn Store4(byte_address_buffer<writable>, offset: u32, value: vec4<u32>)

@member_function fn StoreF16(byte_address_buffer<writable>, offset: u32, value: f16)
@member_function fn Store2F16(byte_address_buffer<writable>, offset: u32, value: vec2<f16>)
@member_function fn Store3F16(byte_address_buffer<writable>, offset: u32, value: vec3<f16>)
@member_function fn Store4F16(byte_address_buffer<writable>, offset: u32, value: vec4<f16>)

@member_function fn GetDimensions[A: access](byte_address_buffer<A>, width: ptr<function, u32, writable>)

@member_function fn GetDimensions[T: fiu32](texture: texture_1d<T>,
                                              width: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_1d<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                              num_levels: ptr<function, u32, writable>)

@member_function fn GetDimensions[F: texel_format, A: access](texture: texture_storage_1d<F, A>,
                                                                width: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_2d<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_2d<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                         num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions[F: texel_format, A: access](texture: texture_storage_2d<F, A>,
                                                                width: ptr<function, u32, writable>,
                                                               height: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_2d_array<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                           elements: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_2d_array<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                           elements: ptr<function, u32, writable>,
                                         num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions[F: texel_format, A: access](texture: texture_storage_2d_array<F, A>,
                                                                width: ptr<function, u32, writable>,
                                                               height: ptr<function, u32, writable>,
                                                             elements: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_3d<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                              depth: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_3d<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                              depth: ptr<function, u32, writable>,
                                         num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions[F: texel_format, A: access](texture: texture_storage_3d<F, A>,
                                                                width: ptr<function, u32, writable>,
                                                               height: ptr<function, u32, writable>,
                                                                depth: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_cube<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_cube<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                         num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_cube_array<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                           elements: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_cube_array<T>,
                                              level: u32,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                           elements: ptr<function, u32, writable>,
                                         num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions[T: fiu32](texture: texture_multisampled_2d<T>,
                                              width: ptr<function, u32, writable>,
                                             height: ptr<function, u32, writable>,
                                            samples: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_2d,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_2d,
                                    level: u32,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                               num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_2d_array,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                                 elements: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_2d_array,
                                    level: u32,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                                 elements: ptr<function, u32, writable>,
                               num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_cube,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_cube,
                                    level: u32,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                               num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_cube_array,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                                 elements: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_cube_array,
                                    level: u32,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                                 elements: ptr<function, u32, writable>,
                               num_levels: ptr<function, u32, writable>)
@member_function fn GetDimensions(texture: texture_depth_multisampled_2d,
                                    width: ptr<function, u32, writable>,
                                   height: ptr<function, u32, writable>,
                                  samples: ptr<function, u32, writable>)

@member_function fn Load[T: fiu32](texture: texture_1d<T>, location: vec2<i32>) -> vec4<T>
@member_function fn Load[T: fiu32](texture: texture_2d<T>, location: vec3<i32>) -> vec4<T>
@member_function fn Load[T: fiu32](texture: texture_2d_array<T>, location: vec4<i32>) -> vec4<T>
@member_function fn Load[T: fiu32](texture: texture_multisampled_2d<T>,
                                  location: vec2<i32>,
                              sample_index: i32) -> vec4<T>
@member_function fn Load[T: fiu32](texture: texture_3d<T>, location: vec4<i32>) -> vec4<T>

@member_function fn Load(texture: texture_depth_2d, location: vec3<i32>) -> vec4<f32>
@member_function fn Load(texture: texture_depth_2d_array, location: vec4<i32>) -> vec4<f32>
@member_function fn Load(texture: texture_depth_multisampled_2d,
                                  location: vec2<i32>,
                              sample_index: i32) -> vec4<f32>

@member_function fn Load[F: f32_texel_format, A: readable](texture: texture_storage_1d<F, A>,
                                                          location: vec2<i32>) -> vec4<f32>
@member_function fn Load[F: f32_texel_format, A: readable](texture: texture_storage_2d<F, A>,
                                                          location: vec3<i32>) -> vec4<f32>
@member_function fn Load[F: f32_texel_format, A: readable](texture: texture_storage_2d_array<F, A>,
                                                          location: vec4<i32>) -> vec4<f32>
@member_function fn Load[F: f32_texel_format, A: readable](texture: texture_storage_3d<F, A>,
                                                          location: vec4<i32>) -> vec4<f32>

@member_function fn Load[F: u32_texel_format, A: readable](texture: texture_storage_1d<F, A>,
                                                          location: vec2<i32>) -> vec4<u32>
@member_function fn Load[F: u32_texel_format, A: readable](texture: texture_storage_2d<F, A>,
                                                          location: vec3<i32>) -> vec4<u32>
@member_function fn Load[F: u32_texel_format, A: readable](texture: texture_storage_2d_array<F, A>,
                                                          location: vec4<i32>) -> vec4<u32>
@member_function fn Load[F: u32_texel_format, A: readable](texture: texture_storage_3d<F, A>,
                                                          location: vec4<i32>) -> vec4<u32>


@member_function fn Load[F: i32_texel_format, A: readable](texture: texture_storage_1d<F, A>,
                                                          location: vec2<i32>) -> vec4<i32>
@member_function fn Load[F: i32_texel_format, A: readable](texture: texture_storage_2d<F, A>,
                                                          location: vec3<i32>) -> vec4<i32>
@member_function fn Load[F: i32_texel_format, A: readable](texture: texture_storage_2d_array<F, A>,
                                                          location: vec4<i32>) -> vec4<i32>
@member_function fn Load[F: i32_texel_format, A: readable](texture: texture_storage_3d<F, A>,
                                                          location: vec4<i32>) -> vec4<i32>

@member_function fn InterlockedCompareExchange(byte_address_buffer<read_write>,
                                    offset: iu32,
                             compare_value: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedExchange(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedAdd(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedMax(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedMin(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedAnd(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedOr(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
@member_function fn InterlockedXor(byte_address_buffer<readable>,
                                    offset: iu32,
                                     value: iu32,
                            original_value: ptr<function, iu32, read_write>)
