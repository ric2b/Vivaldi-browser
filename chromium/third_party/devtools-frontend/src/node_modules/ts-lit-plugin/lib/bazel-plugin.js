"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
var lit_analyzer_1 = require("lit-analyzer");
var typescript_1 = __importDefault(require("typescript"));
var translate_diagnostics_js_1 = require("./ts-lit-plugin/translate/translate-diagnostics.js");
/**
 * Implements bazel's DiagnosticPlugin interface, so that we can run
 * the ts-lit-plugin checks as part of bazel compilation.
 */
var Plugin = /** @class */ (function () {
    function Plugin(program, config) {
        this.name = "lit";
        this.name = "lit";
        var context = new lit_analyzer_1.DefaultLitAnalyzerContext({
            getProgram: function () {
                return program;
            }
        });
        context.updateConfig((0, lit_analyzer_1.makeConfig)(config));
        this.context = context;
        this.analyzer = new lit_analyzer_1.LitAnalyzer(context);
    }
    Plugin.prototype.getDiagnostics = function (sourceFile) {
        var e_1, _a;
        var litDiagnostics = this.analyzer.getDiagnosticsInFile(sourceFile);
        var diagnostics = (0, translate_diagnostics_js_1.translateDiagnostics)(litDiagnostics, sourceFile, this.context);
        try {
            for (var diagnostics_1 = __values(diagnostics), diagnostics_1_1 = diagnostics_1.next(); !diagnostics_1_1.done; diagnostics_1_1 = diagnostics_1.next()) {
                var diagnostic = diagnostics_1_1.value;
                if (diagnostic.category === typescript_1.default.DiagnosticCategory.Warning) {
                    // In bazel something is either an error that breaks the build, or
                    // we don't want to report it at all.
                    diagnostic.category = typescript_1.default.DiagnosticCategory.Error;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (diagnostics_1_1 && !diagnostics_1_1.done && (_a = diagnostics_1.return)) _a.call(diagnostics_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return diagnostics;
    };
    return Plugin;
}());
exports.Plugin = Plugin;
