<!DOCTYPE html>
<!--
Terminate a worker while it's doing readback and video encoding
-->
<title>Frame readback in a worker</title>
<script src="webcodecs_common.js"></script>
<script type="text/javascript" id="worker-script">
  'use strict';

  self.onmessage = async function(e) {
    const frame = e.data;
    const encoder_config = {
        codec: 'vp8',
        hardwareAcceleration: 'prefer-software',
        width: frame.visibleRect.width,
        height: frame.visibleRect.height,
        bitrate: 5000000,
        framerate: 24,
        latencyMode: "realtime"
    };
    let resolve_callback = null;
    const encoder_init = {
        output(chunk, metadata) {
          resolve_callback(chunk);
        },
        error(e) {}
    };
    const encoder = new VideoEncoder(encoder_init);
    encoder.configure(encoder_config);
    encoder.encode(frame);
    await new Promise((resolve) => { resolve_callback = resolve; });

    postMessage(null, []);

    for (let i = 1; i < 100; i++) {
      const new_frame = new VideoFrame(frame,
            { timestamp: frame.timestamp + 1000 * i });
      encoder.encode(new_frame);
      await new Promise((resolve) => { resolve_callback = resolve; });
    }
  }

</script>
<script type="text/javascript">
  'use strict';

  function makeWorker() {
    const script = document.getElementById('worker-script').innerText;
    const url = URL.createObjectURL(new Blob([script]));
    const worker = new Worker(url);
    let resolve_promise = null;
    worker.onmessage = function(e) { resolve_promise(e.data); }
    let worker_promise = new Promise((resolve) => {
      resolve_promise = resolve;
    });
    return { worker, worker_promise };
  }

  async function main(arg) {
    let source_type = arg.source_type;
    TEST.log('Starting test with arguments: ' + JSON.stringify(arg));
    let source = await createFrameSource(source_type, 320, 240);
    if (!source) {
      TEST.skip('Unsupported source: ' + source_type);
      return;
    }

    let frame = await source.getNextFrame();
    let {worker, worker_promise} = makeWorker();
    worker.postMessage(frame, [frame]);
    await worker_promise;

    worker.terminate();

    frame.close();
    source.close();
    TEST.log('Worker termination initiated');
  }
  addManualTestButton([{'source_type': 'offscreen'}]);
</script>
